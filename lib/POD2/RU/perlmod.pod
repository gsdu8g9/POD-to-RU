=encoding utf8

=head1 NAME/НАИМЕНОВАНИЕ

perlmod - Perl модули (пакеты и таблицы симолов)

=head1 ОПИСАНИЕ

=head2 Пакеты
X<package> X<namespace> X<variable, global> X<global variable> X<global>

Perl предоставляет механизм изменения пространства имен для защиты пакетов от
засорения друг друга всеми своими переменными. Фактически, в Perl нет такой 
вещи, как глобальные переменные. Инструкция package объявляет единицу
компиляции, находящуюся в данном пространстве имен. Область действия
объявления пакета начинается от самого объявления и простирается до конца
окружающего блока, C<eval> или файла, в зависимости от того, что будет первым
(такую же область имеют операторы my() и local()). Неполные (неквалифицированные)
динамические идентификаторы будут находится в этом пространстве имен, за 
исключением тех немногих идентификаторов, которые, будучи
неквалифицированными, по умолчанию находятся в пакете main, как будет описано
ниже. Инструкция package затрагивает только динамические
переменные--включая те, к которым применили local() -- но I<не> лексические 
переменные, создаваемые при помощи my(). Обычно package будет первым
объявлением в файле, который вы подключаете используя операторы C<do>,
C<require> или C<use>. Вы можете переключится в пакет в различных местах; это
переключение влият только на то, какая таблица символов будет использоваться
компилятором до конца этого блока. На переменные и файловые указатели в пакете
можно ссылаться из других пакетов, предваряя имя переменной именем пакета и
двойным двоеточием: C<Package::Variable>. Если имя пакета отсутствует,
подразумевается пакет main. То есть C<$::sail> эквивалентно C<$main::seil>.

В старых пакетах разделителем пакета служила одинарная кавычка, но сейчас
предпочтительно использовать двойное двоеточие, оно более человекочитаемо, и
также лучше читается в макросах B<emacs>. Также два двоеточия позволяют С++ 
программистам чувствовать, что они понимают, что происходит -- в отличии от 
разделителя одинарная кавычка, позволявшей испытывать похожее чувство Ada
программистам. Поскольку старомодный синтаксис все еще поддерживается для
обеспечения обратной совместимости, если вы попытаетесь использовать подобную
строку C<"This is $owner's house">, вы обратитесь к C<$owner::s>; то есть, к
переменной $s в пакете C<owner>, что вероятно не то, что вы хотели.
Используйте фигурные скобки для устранения неоднозначности, как здесь C<"This is ${owner}'s house">.
X<::> X<'>

Пакеты сами могут содержать разделители пакетов, например
C<$OUTER::INNER::var>. Однако это ничего не подразумевает о порядке поиска 
имен. Нет относительных пакетов: все символы либо локальны в текущем пакете, 
либо должны быть полностью квалифицированы от внешнего пакета.  Например, в 
пакете C<OUTER> ничто не позволит C<$INNER::var> относиться к 
C<$OUTER::INNER::var>. C<INNER> относится к полностью отдельному глобальному 
пакету.

В таблице символов пакета хранятся только идентификаторы, начинающиеся с 
буквы или знака подчеркивания. Все другие символы, включая пунктуационные
переменные подобно C<$_>, хранятся в пакете C<main>. В добавок, идентификаторы 
STDIN, STDOUT, STDERR, ARGV, ARGVOUT, ENV, INC и SIG, если они не
квалифицированы, принудительно помещаются в C<main>, даже когда они
используются для других целей, нежели предназначены изначально.  Если вы 
назовете свои пакеты C<m>, C<s> или C<y>, вы не сможете использовать
квалифицированую форму идентификатора, поскольку она будет интерпретирована
как поиск по шаблону, замена или транслитерация, соответственно.
X<variable, punctuation> 

Переменные, начинающиеся с нижнего подчеркивания, ранее использовались для
принудительного помещения в пакет C<main>, но мы решили, что они более полезны
разработчикам пакетов для индикации имен приватных переменных и методов. 
Однако, имена переменных и функций, состоящие из едиственного C<_>, такие как 
C<$_> или C<sub _>, по прежнему принудительно находятся в пакете C<main>.
Смотрите также L<perlvar/"The Syntax of Variable Names">.

Обрабатываемые C<eval>-ом строки компилируются в том же пакете, в котором
компилируется eval(). (Однако, при присваивании C<$SIG{}> полагается, что
обработчик сигнала определен в пакете C<main>. Квалифицируйте имя обработчика
сигнала, если хотите использовать обработчик сигнала из пакета.) Для примера
взгляните на F<perldb.pl> из библиотеки Perl. В начале работы он переключается
на пакет C<DB> так, что отладчик не мешает работать с переменными в
отлаживаемой программе.

В различных точках, однако он
временно переключает обратно в пакет (package) C<main> для выполнения различных
выражений в контексте пакета C<main> (или в том пакете, откуда вы пришли). 
Смотрите L<perldebug>.

Специальный символ C<__PACKAGE__> содержит текущий пакет (package), но не может
(легко) использоваться для создания имен переменных.

Смотрите L<perlsub> для вопросов, связанных (for other scoping issues related) с my() и local() 
и L<perlref> для описания замыканий (regarding closures).

=head2 Таблицы символов (Symbol Tables)
X<symbol table> X<stash> X<%::> X<%main::> X<typeglob> X<glob> X<alias>

Таблица символов пакета храниться в хэше с именем, за которым идут два двоеточия.
Главной таблицей символов, таким образом, будет C<%main::>, или C< %:: > для краткости. 
Аналогичным образом таблицой символов для вложенных пакетов
является упоминаемое ранее имя C<%OUTER::INNER::>.

Значением в каждой записи хэша является то, что вы имеете в виду когда вы
используйте typeglob (глобальный тип) нотацию C<*name>.

    local *main::foo    = *main::bar;

Вы можете использовать это, например для того, чтобы распечатать все переменные в пакете.
Стандартная, но устаревшая библиотека F<dumpvar.pl> и CPAN модуль Devel::Symdump используют это.

Результаты создания новых записей в таблице символов непосредственно или изменение любой
записи, которые уже не являются typeglobs, не определены и являются предметом изменения
 в следующих релизах perl (subject to change between releases of perl). 

Присвоение тайпглобу (глобальном типу, typeglob) выполняет операцию алиасирования (сделать псевдоним, синонимирования, другое имя тому же объекту), т.е.
(Assignment to a typeglob performs an aliasing operation, i.e.,)

    *dick = *richard;

приводит к тому, что переменные, подпрограммы, форматы и дескрипторы  файлов и каталогов
доступные через идентификатор C<richard> также будут быть доступны через
идентификатор C<dick>. Если, вместо этого, вы хотите сделать алиас (псевдоним) 
только для конкретной переменной или подпрограммы, присвойте ссылку:

    *dick = \$richard;

Что делает $richard и $dick той же переменной, но оставляет
@richard и @dick независимыми массивами. Хитро, да? (Tricky, eh?)

Существует один тонкое (subtle) различие между следующими инструкциями:

    *foo = *bar;
    *foo = \$bar;

C<*foo = *bar> делает тайпглобы синонимами на самих себя, тогда как (makes the typeglobs themselves synonymous while)
C<*foo = \$bar> делает СКАЛЯРНЫЕ части  двух отдельных тайпглобов (typeglobs) СКАЛЯРНЫХ portions of two distinct typeglobs
ссылающимися на теже скалярное значение (refer to the same scalar value). Это означает, что следующий код:

    $bar = 1;
    *foo = \$bar;       # Делает $foo алиасом для $bar

    {
        local $bar = 2; # Изменение ограничено блоком (Restrict changes to block)
        print $foo;     # Напечатает '1'!
    }

Будет печатать '1',  потому что C<$foo> содержит ссылку на I<оригинал>
C<$bar>. На тот, который был наполнен независимо от C<local()> и, который будет
восстановлен, когда блок закончится. Поскольку переменные доступны через
тайпглоб (typeglob), вы можете использовать  C<*foo = *bar>, чтобы создать псевдоним, который будет
локальным. (Однако следует знать, что это означает, что вы не сможете иметь отдельных
C<@foo> и C<@bar>, и т.д.)

Все это становится важным, потому что модуль Exporter использует глоб алиасинг (glob
aliasing ) как механизм импорта/экспорта. Сможете ли вы или нет правильно
локализовать переменную, которая была экспортирована из модуля зависит от того, как
эта она экспортировалась:

    @EXPORT = qw($FOO); # Обычная форма, не можеть быть локализована
    @EXPORT = qw(*FOO); # Можеть быть локализована

Вы можете обойти (work around) это в первом случае, 
используя полное имя (C<$Package::FOO>) там, где требуется локальное значение, 
или путем переопределения его сказав, C<*FOO = *Package::FOO> в скрипте.

Механизм C<*x = \$y>  может использоваться для передачи и возврата дешевой ссылки
в или из подпрограмм, если вы не хотите, копировать переменную целиком. 
Это работает только при присваивании динамических переменных, не лексических.

    %some_hash = ();			# не может быть my()
    *some_hash = fn( \%another_hash );
    sub fn {
	local *hashsym = shift;
	# теперь используем %hashsym нормально, и вы
	# будет влиять на вызвавшего процедуру (caller's) %another_hash
	my %nhash = (); # делаете то, что вы хотите
	return \%nhash;
    }

По возврате значения из процедуры, ссылка будет перезаписывать хэш слот в
таблице символов, указанный в тайпглобе *some_hash. 
Это несколько хитрый способ передачи сылки дешево,
когда вы не хотите помнить обязанность разыменовать переменные
явным образом.

Другое использование таблиц символов — для создания "постоянных" скаляров.
X<constant> X<scalar, constant>

    *PI = \3.14159265358979;

Теперь вы не сможете изменить C<$PI>, что, вероятно, является, в общем, хорошей вещью.
Это не то же самое, как постоянная подпрограмма, которая подлежит
оптимизации во время компиляции. Постоянная подпрограмма (constant subroutine) является одним прототипом
не принимающим аргументов и возвращает константное выражение. См.
L<perlsub> для подробной информации о них. Прагма C<use constant> является
удобным сокращением для этого.

Вы можете распечтатать значения C<*foo{PACKAGE}> и C<*foo{NAME}>, чтобы узнать, из какого имени и
 из какого пакета появляется *foo в таблице символов. Это может быть полезным
в подпрограмме, которой передаются тайпглобы в качестве аргументов:

    sub identify_typeglob {
        my $glob = shift;
        print 'You gave me ', *{$glob}{PACKAGE}, '::', *{$glob}{NAME}, "\n";
    }
    identify_typeglob *foo;
    identify_typeglob *bar::baz;

Это выведет

    You gave me main::foo
    You gave me bar::baz

Нотация C<*foo{THING}>  может также использоваться для получения ссылки на
отдельные элементы *foo. Смотрите L<perlref>.

Определение подпрограммы  (и объявления(declarations), коль на то пошло) 
не обязательно должно находиться в пакете, символьную таблицу которого они
занимают. Вы можете определить подпрограмму за пределами пакета
явно квалифицируя имя подпрограммы:

    package main;
    sub Some_package::foo { ... }   # &foo определяется в пакете Some_package

Это просто краткая запись для присвоения тайпглобу (typeglob) во время компиляции:

    BEGIN { *Some_package::foo = sub { ... } }

и это I<не> то же самое, что писать:

    {
	package Some_package;
	sub foo { ... }
    }

В первых двух версиях тело подпрограммы лексически лежит
 в основном пакете, а I<не> в Some_package. Так
что-то вроде этого:

    package main;

    $Some_package::name = "fred";
    $main::name = "barney";

    sub Some_package::foo {
	print "in ", __PACKAGE__, ": \$name is '$name'\n";
    }

    Some_package::foo();

напечатает:

    in main: $name is 'barney'

вместо:

    in Some_package: $name is 'fred'

Это также имеет последствия для использования SUPER:: квалификатор
(См. L<perlobj>).

=head2 BEGIN, UNITCHECK, CHECK, INIT и END
X<BEGIN> X<UNITCHECK> X<CHECK> X<INIT> X<END>

Существуют блоков специально именованного кода, которые выполняются в начале и в
в конце работающей программы Perl. Это блоки C<BEGIN>,
C<UNITCHECK>, C<CHECK>, C<INIT>, и C<END>.

Эти блоки кода могут быть префиксом C<sub>, что дать внешний вид
подпрограммы (хотя это не считается хорошим стилем). Следует отметить
что эти блоки кода в действительности не существуют как именованные подпрограммы (несмотря на
их внешний вид). Эти блоки дают такую возможность, что вы можете иметь
B<более, чем один> такой блок кода в программе, и они 
B<все> будут выполнены в соответствующий момент. 
Таким образом вы не можете выполнять любой из 
этих блоков кода по имени.

Блок кода C<BEGIN> выполняется как можно скорее, как только он полностью определён
 даже до анализа остального содержимого файла (или строки). 
Вы можете иметь несколько блоков C<BEGIN> внутри файла (или в
выполняемой eval'ом строке); они будут выполнены в порядке определения. Потому что блок C<BEGIN>
выполняется немедленно, он может вытащить определения подпрограмм
и тому подобного из других файлов во времени, чтобы быть видимым для остальной части во времени компиляции
и во время выполнения (compile and run time). После того как блок C<BEGIN> закончился он сразу неопределенным (undefined) и любой
используемый код возвращает в Perl пул своей памяти (memory pool).


Блок кода C<END> выполняется настолько поздно насколько это возможно
, то есть, после того, как Perl завершает выполнение программы и сразу перед тем, как 
интерпретатор выйдет (is being exited), даже если это выход в результате функции die().
(Но если он перетекает в другую программу через C<exec>, или
выдувается из воды по сигналу--вы должны перехватить (trap) это сами
(если вы можете).) Вы можете иметь несколько C<END>блоков в файле--они
будет выполняться в обратном порядке определения; то есть: последний пришел, первый
вышел (last in, first out) (LIFO). C<END> блоки не выполняются при запуске perl с
 ключем C<-c>, или, если происходит сбой компиляции.

Обратите внимание, что блоки кода C<END> B<не> выполняются в конце строки
C<eval()>: если любые блоки кода C<END> создаются в строке C<eval()>,
то они будут выполняться так же, как любой другой C<END> блок пакетного кода
в порядке LIFO сразу перед тем, как интерпретатор будет выходить (just before the interpreter is being exited).

Внутри блока C<END>, C<$?> содержит значение, которые программа
собирается передать C<exit()>. Вы можете изменить C<$?>, чтобы изменить выходное (exit
value of the program) значение программы. Остерегайтесь изменения C<$?> случайно (например, запуск чего-то через C<system>).
X<$?>

Внутри блока C<END>, значение C<${^GLOBAL_PHASE}> будет C<"END">.

Блоки кода C<UNITCHECK>, C<CHECK> и C<INIT> являются полезными для того, чтобы поймать
переход между фазой компиляции и фазой выполнения
основной программы(execution phase of the main program).

Блоки C<UNITCHECK> выполняются только после того, как юнит, определенный им будет откомпилирован. 
Файл основной программы и каждый загружаемый ей модуль - это
единицы компиляции, такие как строка C<eval>s, во время выполнения код компилируется с помощью
конструкции C<(?{ })> в регексе, вызова C<do FILE>, C<require FILE>,
и кода после ключа C<-e> командной строки.

Блоки C<BEGIN> и C<UNITCHECK> не связаны непосредственно фазами
интерпретатора Perl. Они могут быть созданы и выполняться во время любой фазы.

Блоки кода C<CHECK> выполняются только после окончания компиляции фазы <initial>Perl B
и до выполнения начинается, в порядке LIFO. C <CHECK>используются блоки кода
в комплект компилятора Perl для сохранения скомпилированного состояния программы.

C<CHECK> code blocks are run just after the B<initial> Perl compile phase ends
and before the run time begins, in LIFO order.  C<CHECK> code blocks are used
in the Perl compiler suite to save the compiled state of the program.

Inside of a C<CHECK> block, the value of C<${^GLOBAL_PHASE}> will be
C<"CHECK">.

C<INIT> blocks are run just before the Perl runtime begins execution, in
"first in, first out" (FIFO) order.

Inside of an C<INIT> block, the value of C<${^GLOBAL_PHASE}> will be C<"INIT">.

The C<CHECK> and C<INIT> blocks in code compiled by C<require>, string C<do>,
or string C<eval> will not be executed if they occur after the end of the
main compilation phase; that can be a problem in mod_perl and other persistent
environments which use those functions to load code at runtime.

When you use the B<-n> and B<-p> switches to Perl, C<BEGIN> and
C<END> work just as they do in B<awk>, as a degenerate case.
Both C<BEGIN> and C<CHECK> blocks are run when you use the B<-c>
switch for a compile-only syntax check, although your main code
is not.

The B<begincheck> program makes it all clear, eventually:

  #!/usr/bin/perl

  # begincheck

  print         "10. Ordinary code runs at runtime.\n";

  END { print   "16.   So this is the end of the tale.\n" }
  INIT { print  " 7. INIT blocks run FIFO just before runtime.\n" }
  UNITCHECK {
    print       " 4.   And therefore before any CHECK blocks.\n"
  }
  CHECK { print " 6.   So this is the sixth line.\n" }

  print         "11.   It runs in order, of course.\n";

  BEGIN { print " 1. BEGIN blocks run FIFO during compilation.\n" }
  END { print   "15.   Read perlmod for the rest of the story.\n" }
  CHECK { print " 5. CHECK blocks run LIFO after all compilation.\n" }
  INIT { print  " 8.   Run this again, using Perl's -c switch.\n" }

  print         "12.   This is anti-obfuscated code.\n";

  END { print   "14. END blocks run LIFO at quitting time.\n" }
  BEGIN { print " 2.   So this line comes out second.\n" }
  UNITCHECK {
   print " 3. UNITCHECK blocks run LIFO after each file is compiled.\n"
  }
  INIT { print  " 9.   You'll see the difference right away.\n" }

  print         "13.   It merely _looks_ like it should be confusing.\n";

  __END__

=head2 Perl Classes
X<class> X<@ISA>

There is no special class syntax in Perl, but a package may act
as a class if it provides subroutines to act as methods.  Such a
package may also derive some of its methods from another class (package)
by listing the other package name(s) in its global @ISA array (which
must be a package global, not a lexical).

For more on this, see L<perlootut> and L<perlobj>.

=head2 Perl Modules
X<module>

A module is just a set of related functions in a library file, i.e.,
a Perl package with the same name as the file.  It is specifically
designed to be reusable by other modules or programs.  It may do this
by providing a mechanism for exporting some of its symbols into the
symbol table of any package using it, or it may function as a class
definition and make its semantics available implicitly through
method calls on the class and its objects, without explicitly
exporting anything.  Or it can do a little of both.

For example, to start a traditional, non-OO module called Some::Module,
create a file called F<Some/Module.pm> and start with this template:

    package Some::Module;  # assumes Some/Module.pm

    use strict;
    use warnings;

    BEGIN {
        require Exporter;

        # set the version for version checking
        our $VERSION     = 1.00;

        # Inherit from Exporter to export functions and variables
        our @ISA         = qw(Exporter);

        # Functions and variables which are exported by default
        our @EXPORT      = qw(func1 func2);

        # Functions and variables which can be optionally exported
        our @EXPORT_OK   = qw($Var1 %Hashit func3);
    }

    # exported package globals go here
    our $Var1    = '';
    our %Hashit  = ();

    # non-exported package globals go here
    # (they are still accessible as $Some::Module::stuff)
    our @more    = ();
    our $stuff   = '';

    # file-private lexicals go here, before any functions which use them
    my $priv_var    = '';
    my %secret_hash = ();

    # here's a file-private function as a closure,
    # callable as $priv_func->();
    my $priv_func = sub {
        ...
    };

    # make all your functions, whether exported or not;
    # remember to put something interesting in the {} stubs
    sub func1      { ... }
    sub func2      { ... }

    # this one isn't exported, but could be called directly
    # as Some::Module::func3()
    sub func3      { ... }

    END { ... }       # module clean-up code here (global destructor)

    1;  # don't forget to return a true value from the file

Then go on to declare and use your variables in functions without
any qualifications.  See L<Exporter> and the L<perlmodlib> for
details on mechanics and style issues in module creation.

Perl modules are included into your program by saying

    use Module;

or

    use Module LIST;

This is exactly equivalent to

    BEGIN { require 'Module.pm'; 'Module'->import; }

or

    BEGIN { require 'Module.pm'; 'Module'->import( LIST ); }

As a special case

    use Module ();

is exactly equivalent to

    BEGIN { require 'Module.pm'; }

All Perl module files have the extension F<.pm>.  The C<use> operator
assumes this so you don't have to spell out "F<Module.pm>" in quotes.
This also helps to differentiate new modules from old F<.pl> and
F<.ph> files.  Module names are also capitalized unless they're
functioning as pragmas; pragmas are in effect compiler directives,
and are sometimes called "pragmatic modules" (or even "pragmata"
if you're a classicist).

The two statements:

    require SomeModule;
    require "SomeModule.pm";

differ from each other in two ways.  In the first case, any double
colons in the module name, such as C<Some::Module>, are translated
into your system's directory separator, usually "/".   The second
case does not, and would have to be specified literally.  The other
difference is that seeing the first C<require> clues in the compiler
that uses of indirect object notation involving "SomeModule", as
in C<$ob = purge SomeModule>, are method calls, not function calls.
(Yes, this really can make a difference.)

Because the C<use> statement implies a C<BEGIN> block, the importing
of semantics happens as soon as the C<use> statement is compiled,
before the rest of the file is compiled.  This is how it is able
to function as a pragma mechanism, and also how modules are able to
declare subroutines that are then visible as list or unary operators for
the rest of the current file.  This will not work if you use C<require>
instead of C<use>.  With C<require> you can get into this problem:

    require Cwd;		# make Cwd:: accessible
    $here = Cwd::getcwd();

    use Cwd;			# import names from Cwd::
    $here = getcwd();

    require Cwd;	    	# make Cwd:: accessible
    $here = getcwd(); 		# oops! no main::getcwd()

In general, C<use Module ()> is recommended over C<require Module>,
because it determines module availability at compile time, not in the
middle of your program's execution.  An exception would be if two modules
each tried to C<use> each other, and each also called a function from
that other module.  In that case, it's easy to use C<require> instead.

Perl packages may be nested inside other package names, so we can have
package names containing C<::>.  But if we used that package name
directly as a filename it would make for unwieldy or impossible
filenames on some systems.  Therefore, if a module's name is, say,
C<Text::Soundex>, then its definition is actually found in the library
file F<Text/Soundex.pm>.

Perl modules always have a F<.pm> file, but there may also be
dynamically linked executables (often ending in F<.so>) or autoloaded
subroutine definitions (often ending in F<.al>) associated with the
module.  If so, these will be entirely transparent to the user of
the module.  It is the responsibility of the F<.pm> file to load
(or arrange to autoload) any additional functionality.  For example,
although the POSIX module happens to do both dynamic loading and
autoloading, the user can say just C<use POSIX> to get it all.

=head2 Making your module threadsafe
X<threadsafe> X<thread safe>
X<module, threadsafe> X<module, thread safe>
X<CLONE> X<CLONE_SKIP> X<thread> X<threads> X<ithread>

Perl supports a type of threads called interpreter threads (ithreads).
These threads can be used explicitly and implicitly.

Ithreads work by cloning the data tree so that no data is shared
between different threads. These threads can be used by using the C<threads>
module or by doing fork() on win32 (fake fork() support). When a
thread is cloned all Perl data is cloned, however non-Perl data cannot
be cloned automatically.  Perl after 5.8.0 has support for the C<CLONE>
special subroutine.  In C<CLONE> you can do whatever
you need to do,
like for example handle the cloning of non-Perl data, if necessary.
C<CLONE> will be called once as a class method for every package that has it
defined (or inherits it).  It will be called in the context of the new thread,
so all modifications are made in the new area.  Currently CLONE is called with
no parameters other than the invocant package name, but code should not assume
that this will remain unchanged, as it is likely that in future extra parameters
will be passed in to give more information about the state of cloning.

If you want to CLONE all objects you will need to keep track of them per
package. This is simply done using a hash and Scalar::Util::weaken().

Perl after 5.8.7 has support for the C<CLONE_SKIP> special subroutine.
Like C<CLONE>, C<CLONE_SKIP> is called once per package; however, it is
called just before cloning starts, and in the context of the parent
thread. If it returns a true value, then no objects of that class will
be cloned; or rather, they will be copied as unblessed, undef values.
For example: if in the parent there are two references to a single blessed
hash, then in the child there will be two references to a single undefined
scalar value instead.
This provides a simple mechanism for making a module threadsafe; just add
C<sub CLONE_SKIP { 1 }> at the top of the class, and C<DESTROY()> will
now only be called once per object. Of course, if the child thread needs
to make use of the objects, then a more sophisticated approach is
needed.

Like C<CLONE>, C<CLONE_SKIP> is currently called with no parameters other
than the invocant package name, although that may change. Similarly, to
allow for future expansion, the return value should be a single C<0> or
C<1> value.

=head1 SEE ALSO

See L<perlmodlib> for general style issues related to building Perl
modules and classes, as well as descriptions of the standard library
and CPAN, L<Exporter> for how Perl's standard import/export mechanism
works, L<perlootut> and L<perlobj> for in-depth information on
creating classes, L<perlobj> for a hard-core reference document on
objects, L<perlsub> for an explanation of functions and scoping,
and L<perlxstut> and L<perlguts> for more information on writing
extension modules.

=head1 ПЕРЕВОДЧИКИ
  
=over

=item * Николай Мишин C<< <mi@ya.ru> >>

=item * Андрей Асякин C<< <asan999 at gmail.com> >>
  
=back


