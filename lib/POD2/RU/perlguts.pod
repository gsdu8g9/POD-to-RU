=encoding utf8

=head1 NAME/НАИМЕНОВАНИЕ

perlguts - Введение в Perl API

=head1 ОПИСАНИЕ

Этот документ пытается описать использование Perl API и дать некоторую
информацию об основах работы ядра Perl. Он далеко не полон и, возможно, 
содержит много ошибок. Пожулайста, обращайтесь с любыми вопросами или 
коментариями к автору статьи.

=head1 Переменные

=head2 Типы данных

В Perl есть три определения типа для обработки трех основных типо данных Perl:
Perl has three typedefs that handle Perl's three main data types:

    SV  Скаляр
    AV  Массив
    HV  Хэш

Для каждого определения имеются спецефические процедуры для манипуляции
различными типами данных.

=head2 Что такое "IV"?

Perl использует typedef IV для определения обычного знакового integer,что 
гарантирует достаточный размер для хранения указателя (и самого integer).
Также есть определение UV, то есть просто беззнаковый IV.

Perl также использует два специальных определения типа I32 и I16, длина
которых всегда ьудет как минимум 32 и 16 бит, соответственно. (Аналогично есть 
U32 и U16.) Обычно эти типы равны точно 32 и 16 битам, но на Crays они оба 
будут занимать 64 бита.

=head2 Работа с SV

SV можно создать и инициализировать  одной командой. ПОддерживается загрузка 
пяти типов значений: integer (IV), беззнаковый integer (UV), double (NМ),
строка (PV) и другой скаляр (SV). ("PV" означает "Pointer Value". Вам может
показаться, что для указателя только на строки это неверное название. Однако в
PV возможно хранить что то другое, например, указатель на массив UV. Но при
этом надо проявлять осторожность, так как большая часть внутренних механизмов
ожидает в PV только строку. Например, часто происходит автоматическое 
добавление C<NUL>. Использование PV с не-строками описано здесь только в этом
параграфе.) 

Семь процедур:

    SV*  newSViv(IV);
    SV*  newSVuv(UV);
    SV*  newSVnv(double);
    SV*  newSVpv(const char*, STRLEN);
    SV*  newSVpvn(const char*, STRLEN);
    SV*  newSVpvf(const char*, ...);
    SV*  newSVsv(SV*);

C<STRLEN> имеет тип integer (Size_t, обычно определяемый в F<config.h> как 
size_t), достаточно большой для хранения любой строки, которую может
обработать Perl. 

В редких случаях, когда требуется более сложная инициализация, можно
использовать newSV(len) для создания пустого SV. При C<len>, равном нулю,
возвращается пустой SV типа NULL, иначе возвращается SV типа PV с выделенными
len + 1 (для С<NUL>) байтами памяти, доступными через SvPVX. В обоих случаях
SV имеет undef значение.

    SV *sv = newSV(0);   /* память не выделяется */
    SV *sv = newSV(10);  /* выделяется 10 (+1) байт неинициализированной
                          * памяти allocated */

Для изменения значения I<уже существующего> SV существует восемь функций:

    void  sv_setiv(SV*, IV);
    void  sv_setuv(SV*, UV);
    void  sv_setnv(SV*, double);
    void  sv_setpv(SV*, const char*);
    void  sv_setpvn(SV*, const char*, STRLEN)
    void  sv_setpvf(SV*, const char*, ...);
    void  sv_vsetpvfn(SV*, const char*, STRLEN, va_list *,
                                                    SV **, I32, bool *);
    void  sv_setsv(SV*, SV*);

обратите внимание, что можно либо передавать длину строки в C<sv_setpvn>, 
C<newSVpvn> и C<newSVpv>, либо дать Perl вычислить её в C<sv_setpv> или 
передавая 0 вторым агрументом C<newSVpv>. Однако будьте внимательны, так как 
для вычисления длины используется C<strlen>, которая зависит от наличия 
завершающего C<NUL> и отсутствия других NUL внутри строки. 

Аргументы C<sv_setpvf> обрабатываются подобно аргументам C<sprintf>, значением
будет отформатированный результат.

C<sv_vsetpvfn> является аналогом C<vsprintf>, но позволяет определять либо
указатель на список различных аргументов, либо адрес и длину массива SV. 
Последний аргумент, указатель на boolean, при возврате содержит true, если при
форматировании использовалась локале-специфичная информация и поэтому 
содержимое строки ненадежно (см. L<perlsec>). Если эта информация не важна,
передавайте NULL. Также обратите внимание, что требуется определять длину
строки формата.

Функции C<sv_set*()> не являются достаточно обобщенными для оперирования
значниями с "магией".  Смотрите L<Magic Virtual Tables> далее.

Во всех SV, хранящих строки, строки должны завершаться символом C<NUL>, иначе 
есть риск падения в дамп или порчи программы из кода, который передает их в 
функции C или системные вызовы, ожидающие завершающиеся C<NUL> строки. 
По этой причине собственные функции Perl обычно добавляют завершающий c<NUL>.
Тем не менее, нвдо быть очень осторожным, передавая хранящиеся в SV строки
в C-функии ил системные вызовы.

Для доступа к действиельному содержимому SV могут использоваться макросы:

    SvIV(SV*)
    SvUV(SV*)
    SvNV(SV*)
    SvPV(SV*, STRLEN len)
    SvPV_nolen(SV*)

которые автоматически преобразуют действительный типа скаляра в IV, UV, double
или строку.

C<SvPV> помещает длину возвращаемой строки в переменную C<len> (это макрос, 
поэтому вам I<не> нужно писать C<&len>). Если длина вам не нужна, используйте
C<SvPV_nolen>. По историческим причинам в этом случае используется макрос 
C<SvPV> с глобальной переменной C<PL_na>. Но это может быть довольно
неэффективно, поскольку C<PL_na> должнв быть доступна в локальной памяти
потока в потоковом Perl. В любом случае помните, что в Perl позволяет хранить
в строках произвольные данные, в которых могут быть C<NUL> внутри и не быть
завершающего C<NUL>.

Также помните, что в C нельзя безопасно написать C<foo(SvPV(s, len), len);>.  
Это может проглотить ваш компилятор, но не проглотить другие. Разбивайте такую
запись на отдельные иструкции:

    SV *s;
    STRLEN len;
    char *ptr;
    ptr = SvPV(s, len);
    foo(ptr, len);

Если вы хотите узнать, является ли скалярне значение TRUE, используйте:

    SvTRUE(SV*)
    
Хотя Perl автоматически наращивает строки, если вам понадобилось 
принудительно выделить большее количество памяти для SV,  можно
воспользоваться макросом

    SvGROW(SV*, STRLEN newlen)

который определит, нужно ли дополнительное выделение. Если да, будет вызвана
функция C<sv_grow>. Обратите внимание, что можно только увеличивать, не 
уменьшать, размер памяти для C<SV> в C<SvGROW>, и что при выделении памяти
место для завершающего C<NUL> не добавляется автоматически (строковые функции
самого Perl обычно используют C<SvGROW(sv, len + 1)>).

Если вы хотитите записать в буфер существующего SV и установить это значение,
как строку, используйте SvPV_force() или однин из ее вариантом, чтобы 
принудить SV быть PV. При этом из SV будут удалены любые не приdовдимые к 
строке типы но сохранится содержимое. Этот функционал можно использовать
,например, при добавлении данных в буфер из функций API без дополнительного
копирования:

    (void)SvPVbyte_force(sv, len);
    s = SvGROW(sv, len + needlen + 1);
    /* 
       Нечто, что изменяет до needlen байтов с s+len, но байты newlen
       something that modifies up to needlen bytes at s+len, but
       modifies newlen bytes
         eg. newlen = read(fd, s + len, needlen);
       в этом примере игнорируются ошибки
       ignoring errors for these examples
     */
    s[len + newlen] = '\0';
    SvCUR_set(sv, len + newlen);
    SvUTF8_off(sv);
    SvSETMAGIC(sv);

Если уже есть данные в памяти или вы хотите, что бы код был проще, используйте
один из вариантов sv_catpvn(). Чтобы вставить данные внутрь строки,
используйте sv_insert() или sv_insert_flags(). 

Если не нужно сохранять текущее содержимое SV, избежать копирования можно:

    sv_setpvn(sv, "", 0);
    s = SvGROW(sv, needlen + 1);
    /* something that modifies up to needlen bytes at s, but modifies
       newlen bytes
         eg. newlen = read(fd, s. needlen);
     */
    s[newlen] = '\0';
    SvCUR_set(sv, newlen);
    SvPOK_only(sv); /* also clears SVf_UTF8 */
    SvSETMAGIC(sv);

Повторим, что если у вас уже есть данные в памяти или вам не нравится
сложность кода в пример выше, используйте sv_setpvn().

Если есть буфер, выделенный с помощью Newx() и вы хотите установить его, как
значение SV, используйте sv_usepvn_flags(). Чтобы избежать реаллокации буфера
при добавлении завершающего NUL, длжны быть соблюдены некоторые требования:

   Newx(buf, somesize+1, char);
   /* ... заполняем буфер ... */
   buf[somesize] = '\0';
   sv_usepvn_flags(sv, buf, somesize, SV_SMAGIC | SV_HAS_TRAILING_NUL);
   /* теперь буфер принадлежит perl, не освобождайте его */

Макросы для определения того, что Perl думает о типе данных в SV:

    SvIOK(SV*)
    SvNOK(SV*)
    SvPOK(SV*)

Макросы для получение и установка текущей длины сроки в SV:

    SvCUR(SV*)
    SvCUR_set(SV*, I32 val)
Также можно получить указатель на конец строки:

    SvEND(SV*)

Но имейте ввиду, что последнии три макроса правомерны только если C<SvPOK>
возвращает истину.
 
Макросы для добавления чего-либо в конец сроки в SV:

    void  sv_catpv(SV*, const char*);
    void  sv_catpvn(SV*, const char*, STRLEN);
    void  sv_catpvf(SV*, const char*, ...);
    void  sv_vcatpvfn(SV*, const char*, STRLEN, va_list *, SV **,
                                                             I32, bool);
    void  sv_catsv(SV*, SV*);

Первая функция вычисляет длину добавляемой строки с помощью C<strlen>. Во
вторую вы передаете длину сами. Третья обрабатывает аргументы подобно
C<sprintf> и добавляет отформатированный ресультат. Четвертая работает подобно
C<vsprintf>. Вместо аргумента va_list она может получать массив SV и его 
длину. Пятая функция расширяет строку в первом SV строкой из второго SV. Также
она заставляет второй SV интерпретироваться как строка.

Функции семейства C<sv_cat*()> недостаточно общие, чтобы работать с значениями
с "магией". Смотрите секцию L<Magic Virtual Table> далее.

Если известно имя переменной, можно получить указатель на SV:

    SV*  get_sv("package::varname", 0);

Если переменная не существует, возвращается NULL.

Следующий вызов позволяет узнать, действительно ли C<определена> переменная:

    SvOK(SV*)

Скалярное значение C<undef> хранится в экземпляре SV с именем C<PL_sv_undef>.

Её адрес может использоваться там, где необходим C<SV>. Убедитесь, что вы не
пытаетесь сравнить случайное sv c C<PL_sv_undef>. Например, при взаимодействии
с кодом Perl это работает корректно:

    foo(undef)

а это нет:

    $x = undef;
    foo($x);

Так что повторим, что для проверки определенности всегда используйте SvOK().

Также будьте внимательны, используя C<&PL_sv_undef> в качестве значений AV
или HV (см. L<AVs, HVs и неопределенные значения>). 

Есть еще два значения C<PL_sv_yes> и C<PL_sv_no>, которые содержат логические
TRUE и FALSE, соответственно. Также как и в случае C<PL_sv_undef> должны
использоваться их адреса, когда требуется.

Вы ошибетесь, если решите что C<(SV *) 0> то же самое, что и C<&PL_sv_undef>.
Возьмем код:

    SV* sv = (SV*) 0;
    if (I-am-to-return-a-real-value) {
            sv = sv_2mortal(newSViv(42));
    }
    sv_setsv(ST(0), sv);

Этот код пытается вернуть новый SV (содержащий 42), если нужно реальное 
значение, или undef в ином случае. Вместо этого он вернет NULL, что где-нибудь
ниже приведет к нарушению сегментации, ошибке шины или просто странным
Замените ноль в первой строке на C<&PL_sv_undef> и все станет нормально.

Для освобождения ранее созданного SV служит C<SvREFCNT_dec(SV*)>. Обычно этот
вызов не требуется (смотрите L<ПОдсчет Ссылок и Смертность>).

=head2 Смещения

Для эффективного удаления символов из начала строки используется C<sv_chop>;
она принимает SV и указатель на какое-либо место внутри PV, и отбрасывает
все до этого указателя. Эффективность достигется небольшим хаком: вместо
реального удаления символов C<sv_chop> устанавливает флаг C<OOK> (offset OK).
чтобы другие функции могли понять, что используется смещение. Указатель PV
(C<SvPVX>)перемещается вперед на число отброшенных символов, и соответствующим
образом устанавливаются C<SvCUR> и C<SvLEN>. (Часть места между старым и новым
PV используется для хранения числа отрезанных байтов)

С этого момента начало лежащего в памяти буфера находится по адресу 
C<SvPVX(sv) - SvIV(sv)> и PV указывает куда то в его середину.

Лучше продемонстрировать сказанное примером. Обычно механизм copy-on-write препятствует
использованию этого хака из оператора замены, но если вы сможете смастерить троку, на которой
copy-on-write невозможен, то получится увидеть действии хака. В текущей реализации финальный байт
строкового буфера используется в качестве счетчика ссылок copy-on-write. Если буфер недостаточно
большой, copy-on-write пропускается. Возьмем для начала пустую строку:

  % ./perl -Ilib -MDevel::Peek -le '$a=""; $a .= ""; Dump $a'
  SV = PV(0x7ffb7c008a70) at 0x7ffb7c030390
    REFCNT = 1
    FLAGS = (POK,pPOK)
    PV = 0x7ffb7bc05b50 ""\0
    CUR = 0
    LEN = 10
Обратите внимание, что LEN равно 10. (На вышей платформе может быть другое значение.) Увеличим
строку до длины, на единицу меньше 10, и сделаем замену:

  % ./perl -Ilib -MDevel::Peek -le '$a=""; $a.="123456789"; $a=~s/.//; Dump($a)'
  SV = PV(0x7ffa04008a70) at 0x7ffa04030390
    REFCNT = 1
    FLAGS = (POK,OOK,pPOK)
    OFFSET = 1
    PV = 0x7ffa03c05b61 ( "\1" . ) "23456789"\0
    CUR = 8
    LEN = 9

  % ./perl -Ilib -MDevel::Peek -le '$a=""; $a.="123456789"; $a=~s/.//; Dump($a)'
  SV = PV(0x7ffa04008a70) at 0x7ffa04030390
    REFCNT = 1
    FLAGS = (POK,OOK,pPOK)
    OFFSET = 1
    PV = 0x7ffa03c05b61 ( "\1" . ) "23456789"\0
    CUR = 8
    LEN = 9

В OFFSET показано число отрезанных байтов. Часть строки между "реальным" и "фальшимым" началом
показана в скобках, и значения C<SvCUR> и C<SvLEN> отражают фальшивое начало строки, а не реальное.
(Первый символ строкового буфера изменяется на "\1", поскольку текущая реализация сохраняет там
счетчик смещения. Замена такого поведения является темой дискурсий.)

Нечто подобное хаку со смещением применяется и c типом AV для реализации эффективного сдвига и
замены в начале массива; в то время, как C<AvARRAY> указывает на первый элемент массива, видимого в
Perl, C<AvALLOC> указывает на реальное начало C-массива. Обычно они равны, но операция C<shift>
может увеличить на единицу C<AvARRAY> и уменьшить на единицу C<AvFILL> и C<AvMAX>. Опять таки,
местонахождение реального начала массива C вступает в игру только при освобождении массива. Смотрите
C<av_shift> в F<ac.c>.

=head2 Что на Самом Деле Хранится в SV?

Напомним, что для определения типа скаляра обычно используются макросы C<Sv*OK>. Поскольку скаляр
может быть и числом и строкой, эти маркросы почти вегда возвращают  TRUE, а при вызове C<SV*V> 
произойдет соответствующее преобразование строки в integer/double и наоборот.

Если вам I<на самом деле> необходимо знать, находится ли в вашем SV interer, double или указатель на
сроку, вместо C<Sv*OK> используйте следующие три макроса:

    SvIOKp(SV*)
    SvNOKp(SV*)
    SvPOKp(SV*)

Они сообщат вам, что в действительности хранится в SV. "p" здесь означает private.

Есть несколько мест, где приватные и публичные флаги могут отличаться. Например, в perl 5.16 и более
ранних версиях в слоте IV связанного SV могло находиться допустимое значение (SvIOKp - истина), но 
для доступу к данным необходимо использовать процедуру FETCH, а не получать их напрямую, поэтому
SvIOK - ложь. (Начиная с perl 5.18, связанные скаляры используют флаги так же, как ине связанные.)
Другой пример, это числовое преобразование с потерей точности: для 'lossy' значений устанавливается
только приватный флаг. Поэтому, при преобразовании NV в IV с потерей точности, будут установлены 
флаги SvIOKp, SvNOKp и SvNOK , но не SvIOK.

В общем случае, однако, лучше использовать макросы C<Sv*V>.


=head2 Работа с AV

Создать и загрузить AV можно двумя способами. Первый метода создает пустое AV:

    AV* newAV();

Второй метод создает AV и инициализирует его значениями SV:

    AV* av_make(SSize_t num, SV **prt)

Второй аргумент указывает на массив из C<num> C<SV*>. Как только массив создан, эти SV можно
уничтожить, если хочется.

Следующие опреации доступны после создания AV:

    void  av_push(AV*, SV*);
    SV*   av_pop(AV*);
    SV*   av_shift(AV*);
    void  av_unshift(AV*, SSize_t num);

Все эти опреации, вероятно, очевидны, за исключением C<av_unshift>. Эта процедура добавляет C<num>
элементов со значением C<undef> в начало массива. Затем вы должны присвоить значения этим элементам с
помощью описанной ниже C<av_store>.

Еще несколько функций:

    SSize_t av_top_index(AV*);
    SV**    av_fetch(AV*, SSize_t key, I32 lval);
    SV**    av_store(AV*, SSize_t key, SV* val);

C<av_top_index> возвращает наибольшее значение индекса массива (то же самое делает $#array в Perl), 
или -1, если массив пуст.

C<av_fetch> вернет значение по индексу C<key>, но также, если параметр C<lval> не равен нулю,
сохранит неопределенное значение по этому же индексу. C<av_store> сохраняет C<val> по индексу
C<key>, но не увеличивает счетчик ссылок C<val>. Об этом должнв позаботиться вызывающая сторона, и
если C<av_store> вернул NULL, вызывающий дожне уменьшить счетчик ссылок для избежания утечки памяти.
Заметьте, что C<av_fetch> и C<av_store> возвращают C<SV**>, а не C<SV*>.

Еще функции:

    void  av_clear(AV*);
    void  av_undef(AV*);
    void  av_extend(AV*, SSize_t key);

C<av_clear> удаляет все елементы из массива AV*, но не удаляет сам массив. C<av_undef> удалит все
жлементы плюс сам массив. C<av_extend> расшириряет массив, так что он будет содержать как минимум
C<key+1> элементов. Если C<key+1> меньше текущей длины массива, C<av_extend>  ничего не делает.

Если вам известно имя переменной, можно  получить указатель на AV:

    AV*  get_av("package::varname", 0);

Если переменная не существует, возвращается NULL.

В секция L<Понимание Магии Связанных Хэшей и Массивов> содержится больше информации об использовании
функций доступа со связанными массивами.

=head2 Работа с HV

Для создания HV используется следующаяч процедура:

    HV* newHV();

После создания на HV возможны следующие операции:

    SV**  hv_store(HV*, const char* key, U32 klen, SV* val, U32 hash);
    SV**  hv_fetch(HV*, const char* key, U32 klen, I32 lval);

Параметр C<klen> содержит длину передаваемого ключа (заметьте, что в C<klen> нельзя передавать 0,
предлагая Perl самому вычислить длину ключа). Аргумент C<val> содержит указатель типа SV на
сохраняемый  скаляр, и в C<hash> - предварительно вычесленный хэш ключа, или 0, чтобы C<hv_store>
вычислила его сама. Параметр C<lval> используется для указания, что операция получения в
действительности является частью операции  сохранения, в этом случае в HV будет добавлено новое
неопределенное значение по заданному ключу, и C<hv_fetch> вернет его, как если оно уже существовало.

Помните, что C<hv_store> и C<hv_fetch> возвращают C<SV**>, а не просто C<SV*>. Для доступа к
скалярному значению необходимо разименововать вернувшееся значение. Однако, сначала нужно убедиться,
что оно не NULL.

Первая из следующих двух функций проверяет существование записи в хэш-таблице, вторая удаляет
запись:

    bool  hv_exists(HV*, const char* key, U32 klen);
    SV*   hv_delete(HV*, const char* key, U32 klen, I32 flags);

Если C<flags> не включает флаг C<G_DISCARD>, C<hv_delete> создаст и вернет смертную копию удаляемого
значения.

И еще функции:

    void   hv_clear(HV*);
    void   hv_undef(HV*);


Как и парные AV функции, C<hv_clear> удаляет все записи хэш-таблицы, но не удаляет ее саму.
C<hv_undef> удаляет и записи и саму таблицу.

Perl хранит действительные данные в связанном списке структур типа typedef HE. Структура содержит
указатели на ключ и значение (плюс дополнительный административный довесок). Ключ - указатель на
строку; значением является C<SV*>. Однако, как только у вас появляется C<HE*>, для получения ключа и
значения используйте определенные ниже процедуры:

    I32    hv_iterinit(HV*);
            /* Подготавливает точку старта для прохода по хэш-таблице */
    HE*    hv_iternext(HV*);
            /* Получает следующую запись и возвращает указатель на 
               структуру, хранящую ключ и значение */
    char*  hv_iterkey(HE* entry, I32* retlen);
            /* Получает ключ из структуры HE, а также возвращает длину строки с ключом */
    SV*    hv_iterval(HV*, HE* entry);
            /* Возвращает указатель на SV значения из структуры HE */
    SV*    hv_iternextsv(HV*, char** key, I32* retlen);
            /* Удобная процедура, комбинирующая hv_iternext, hv_iterkey и hv_iterval.
               Ключ и его длина возвращаются в аргументах key и retlen, значение 
               возвращается через SV* 
	        */

Если известно имя переменной, можно получить указатель на HV:

    SV*  get_hv("package::varname", 0);

Если переменная не существует, возвращается NULL.

Алгоритм хеширования определен через макрос C<PERL_HASH>:

    PERL_HASH(hash, key, klen)

Конкретная реализация этого макроса зависит от архитектуры системы и версии Perl, а возвращаемое
значение может меняться при запуске интерпретатора, так что оно действительно только на время жизни
одного процесса Perl.

В секция L<Понимание Магии Связанных Хэшей и Массивов> содержится больше информации об использовании
функций доступа со связанными массивами.

=head2 Расширенное API Хэшей

Начиная с версии 5.004 доступны следующие функции:

    HE*     hv_fetch_ent  (HV* tb, SV* key, I32 lval, U32 hash);
    HE*     hv_store_ent  (HV* tb, SV* key, SV* val, U32 hash);

    bool    hv_exists_ent (HV* tb, SV* key, U32 hash);
    SV*     hv_delete_ent (HV* tb, SV* key, I32 flags, U32 hash);

    SV*     hv_iterkeysv  (HE* entry);

Обратите внимание, что эти функции принимают ключ в виде C<SV*>, что упрощает написание расширений,
работающих с структурой хэша. Также они позволяют передавать C<SV*> ключей в функции C<tie>, не
заставляя вас стрингифицировать ключи, в отличии от предыдущего набора функций.

Они также возвращают и принимают запись хэша целиком (C<HE*>), что делает их более эффективными
(поскольку не нужно каждый раз вычислять хэш для отдельных строк). Смотрите L<perlapi> для
детального описания.

Для доступа к содержимому записей хэша всегда должны использоваться описанные ниже макросы. Обратите
внимание на то, что в аргументы этих макросов простые переменные, так как они могут определяться
более одного раза.  Смотрите L<perlapi> для детального описания этих макросов.

    HePV(HE* he, STRLEN len)
    HeVAL(HE* he)
    HeHASH(HE* he)
    HeSVKEY(HE* he)
    HeSVKEY_force(HE* he)
    HeSVKEY_set(HE* he, SV* sv)

Далее определяются два низкоуровневых макроса, но они должны использовать только при работе с
ключами, не являющимися C<SV*>:

    HeKEY(HE* he)
    HeKLEN(HE* he)


Заметьте, что за увеличение счетчика ссылок C<val> отвечает вызывающая строна,Ю так как C<hv_store>
и C<hv_store_ent> не инкрементируют его. Если эти фукции возвращают NULL, вызывающему обычно нужно
декрементировать счетчик ссылок C<val>, дабы избежать утечки памяти.

=head2 AV, HV и Неопределенные Значения

Иногда нужно сохранить неопределенное значение в AV или HV. Хотя возможно это нужно в редких
случаях, тут есть хитрости, поскольку вам нужно используете C<&PL_sv_undef> для задания
неопределенного SV.

Например, интуицитивно кажется, что следующий XS код:

    AV *av = newAV();
    av_store( av, 0, &PL_sv_undef );

эквивалентен Perl коду:

    my @av;
    $av[0] = undef;

Это не так, к сожалению. В perl 5.18 и ниже для AV C<&PL_sv_undef> использовался как маркер,
указывающий, что элемент массива еще не инициализирован. Поэтому C<exists $av[0]> будет истинно для
Perl кода, но ложно для массива в XS коде. В perl 5.20 сохранение &PL_sv_undef создаст read-only
элемент, поскольку сохраняется сам скаляр &PL_sv_undef, а не его копия.

Те же самые проблемы могут возникнуть при сохранениии C<&PL_sv_undef> в HV:

    hv_store( hv, "key", 3, &PL_sv_undef, 0 );

Этого достаточно, что бы получить C<undef> значение, но при попытке  модифицировать значение 
C<key> вы получите ошибку:

    Modification of non-creatable hash value attempted

Мы сделаем покороче эту длинную историю, и сообщаем вам, что вы можете использовать специальные
переменные C<&PL_sv_undef>, C<&PL_sv_yes> и C<&PL_sv_no> с AV и HV, но вы должны быть уверены, что
знаете, что делаете.

Итак, если вы хотите хранить неопределенное значение в AV или HV, вы не должны использовать
C<&PL_sv_undef>, вместо этого созайте новое неопределенное значение функцией C<newSV>, например:

    av_store( av, 42, newSV(0) );
    hv_store( hv, "foo", 3, newSV(0), 0 );

=head2 Ссылки

Ссылки - это специальный тип скаляра, указывающего на другие типы данных (включая другие ссылки). 

Для создание ссылки используются следующие функции:

    SV* newRV_inc((SV*) thing);
    SV* newRV_noinc((SV*) thing);


Аргумент C<thing> может быть любым C<SV*>, C<AV*> или C<HV*>.  Функции идентичны, за исключением
того, что C<newRV_inc> увеличивает счетчик ссылок аргумента C<thing>, а C<newRV_noinc> нет. По
историческим причинам C<newRV> является синонимом C<newRV_inc>.

Когда у вас есть ссылка, вы можете разименовать её, используя следующий макрос:

    SvRV(SV*)

и затем, если требуется,  вызвать соответствующую процедуру для преобразования возвращаемого C<SV*> 
в C<AV*> или C<HV*>.

Макрос для определения, является ли SV ссылкой:

    SvRV(SV*)

Для определения типа, на который ссылается ссылка, исследуйте возвращаемое значение следующего
макроса:

    SvTYPE(SvRV(SV*))

Большинство полезных типов вернется как:

    < SVt_PVAV  Scalar
    SVt_PVAV    Array
    SVt_PVHV    Hash
    SVt_PVCV    Code
    SVt_PVGV    Glob (возможно файловый указатель)

Смотрите подробности в L<perlapi/svtype>.

=head2 Освященные Ссылки и Объекты Класса

Ссылки используются также для поддержки объектно-ориентированного программирования. На лексиконе
perl OO объект является просто ссылкой, которая была освящена (blessed) в пакет (или класс). После
освящения программист может использовать ссылку для доступа к различным методам в классе. 

Освятить ссылку в пакет можно следующим образом:

    SV* sv_bless(SV* sv, HV* stash);

Аргумент C<sv> должен быть ссылкой. Аргумент C<stash> определяет, какому классу будет принадлежать
ссылка. Информация о преобразовании имен классов преобразуются в стэши находится в секции 
L<Стэши и Глобы>.

/* Все еще в процессе создания */

Обновление rv до ссылки, если нужно. Создается новый SV, ссылающийся на rv. Если
C<classname> не-null, SV освещается в заданный класс. Возвращается SV.

    SV* newRVrv(SV* rv, const char* classname);

Следующие три функции копируют integer, unsigned integer или double
в SV, ссылка на который находится в C<rv>. SV освящается, если C<classname> не-null.

	SV* sv_setref_iv(SV* rv, const char* classname, IV iv);
	SV* sv_setref_uv(SV* rv, const char* classname, UV uv);
	SV* sv_setref_nv(SV* rv, const char* classname, NV iv);

Копирование указателя (I<адреса, не строки!>) в SV, на который ссылается rv. SV
освящается, если C<classname> не-null.

	SV* sv_setref_pv(SV* rv, const char* classname, void* pv);

Копирование строки в SV, на который ссылается C<rv>. Если length установлен в 0, Perl
Perl сам вычисли длину строки. SV освящается, если C<classname> не-null.

    SV* sv_setref_pvn(SV* rv, const char* classname, char* pv,
                                                         STRLEN length);

Проверяет, является ли SV освященной в данный класс. Иерархия наследования не
проверяется.

	int  sv_isa(SV* sv, const char* name);


Проверить, является ли SV ссылкой на освященный объект.

	int  sv_isobject(SV* sv);

Узнать, наследуется ли SV от определенного класса. SV может быть либо ссылкой на освященный объект,
либо строкой, содержащей имя класса. Эта функция реализуется функциональность C<UNIVERSAL::isa>.

    bool sv_derived_from(SV* sv, const char* name);

Проверку того, что объект является наследником определенного класса, можно написать так:

    if (sv_isobject(sv) && sv_derived_from(sv, class)) { ... }

=head2 Создание Новых Переменных

С помощью сдедующих трех функций можно создать новую переменную с неопределенным значением, 
которая будет доступна в Perl коде:

    SV*  get_sv("package::varname", GV_ADD);
    AV*  get_av("package::varname", GV_ADD);
    HV*  get_hv("package::varname", GV_ADD);

Обратите внимание, что во втором параметре GV_ADD. Установить значение новой 
переменной можно с помощью соответствующие типу данных процедур.

Существуют дополнительные макросы для включения специальных возможностей, объединяемые побитовым OR 
с GV_ADD. 

=over

=item GV_ADDMULTI

Маркировать переменную, как определямую неоднократно, что подавит вывод такого предупредения:

  Name <varname> used only once: possible typo

=item GV_ADDWARN

Вывод предупреждения:

  Had to create <varname> unexpectedly

если переменная не существует до вызова функции.

=back

=head2 Подсчет Ссылок и Смертность

Механизм сборки мусора в Perl управляется через подсчет ссылок. SV, AV или HV (далее xV для 
краткости) начинают жизнь со счетчиком ссылок, равным единиеце. Если счетчик ссылок какого-либо xV
становится равен нулю, xV уничтожается и занимаемая им память становится доступна для повторного 
использования.

Обычно в perl-коде этого не бывает, пока переменная не является неопределенной, или последняя
переменная, удерживающая ссылку на что-либо, не изменяется или не перезаписывается.  На внутреннем 
уровне подсчетом ссылок можно управлять через макросы:

    int SvREFCNT(SV* sv);
    SV* SvREFCNT_inc(SV* sv);
    void SvREFCNT_dec(SV* sv);

Есть еще одна функция, манипулирующая счетчиком ссылок своего аргумента.  C<newRV_inc>, если 
помните, создает ссылку на свой аргумент и, в качестве побочного эффекта, увеличивает его счетчик 
ссылок.  Если вы не хотите увеличивать счетчик ссылок, вместо нее используйте C<newRV_noinc>.  

Например, представьте себе, что вы хотите вернуть ссылку из XSUB функции.  Внутри XSUB вы создаете
SV, ее счетчик ссылок изначально равен единице.  Затем вы вызываете C<newRV_inc> и передаете ей 
только что созданный SV.  C<newRV_inc> возвращает ссылку в новом SV, но счетчик ссылок вашего SV 
увеличился и стал равен двум.  Далее вы возвращаете ссылку из XSUB и забываете об вашем SV. То Perl 
ничего не забывает!  Всякий раз, когда возвращаемая ссылка уничтожается, счетчик ссылок 
оригинального SV уменьшается на единицу, и больше ничего не происходит.  SV будет торчать в памяти, 
не имея никакого способа доступа, пока сам Perl не завершится.  Это утечка памяти.

В данном случае правильным выбором будет использовать C<newRV_noinc> вместо C<newRV_inc>.  Тогда
после уничтожения последней ссылки счетчик ссылок SV достигет нуля и SV уничтожится, и утечки памяти
не будет.

Есть несколько удобных функций, помогающих уничтожать SV.  Эти функции вводят концепцию "смертости" 
(mortal SV).  Счетчик ссылок смертного SV помечен, как подлежащий уменьшению, но реальное его 
уменьшение произойдет через "короткий отрезок времени".  Термин "короткий отрезок времени" обычно
означает выполнение одной инструкции Perl, такой, как вызов XSUB.  Фактичесий момент уменьшения 
счетчика ссылок SV зависит от двух макросов, SAVETMPS и FREETMPS.  Смотрите L<perlcall> и L<perlxs>.


В самом простом случае "мортализация", это отложенный вызов C<SvREFCNT_dec>.  Если, однако,
вы "мортализируете" переменную дважды, в последствии счетчик ссылок также уменьшится дважды. 

"Мортализация" в основном используется для SV, хранящихся в стеке Perl.  Например, SV, созданный
только лишь для передачи числа в вызываемую функцию, делается смертным для автоматической зачистки
его после выталкивания из стека.  Также, часто делается смертным результат (хранящийся на стеке) 
вызова XSUB. 

Создание смертной переменной:

    SV*  sv_newmortal()
    SV*  sv_2mortal(SV*)
    SV*  sv_mortalcopy(SV*)

Первый вызов создает пустое смертное SV, второй конвертирует обычное SV в смертное (и таким образом,
создает отложенный вызов C<SvREFCNT_dec>), третий создает смертную копию SV.  Так как 
C<sv_newmortal> дает нам новое SV без значения, значение нужно установить обычным образом через
C<sv_setpv>, C<sv_setiv> и т.д.:

    SV *tmp = sv_newmortal();
    sv_setiv(tmp, an_integer);

Зачастую вместо двух C инстукций встречается следующая идиома:

    SV *tmp = sv_2mortal(newSViv(an_integer));

Нужно быть внимательным при создании смертных переменных.  Странные вещи могут происходить, если
одно и тоже значение сделать смертым в нескольких контекстах, или или несколько раз. Думайте о 
"мортализации", как об откладывании вызова C<SvREFCNT_dec>, это уменьшит количество
проблем.  Например, если вы C<знаете>, что счетчик ссылок переменной достаточно велик и она
переживет передачу через стек, не нужно использовать мортализацию.  Если уверенности нет, вызовите
C<sv_REFCNT_dec> и C<sv_2mortal>, или C<sv_mortalcopy> для надежности.

Смертные функции используются не только с SV: в C<sv_2mortal> и C<sv_mortalcopy> можно передавать
адреса AV и HV (приведя их к типу C<SV*>).

=head2 Стеши и Глобы

B<Стеш> - это хеш, содержащий все определенные в пакете переменные.  Каждый ключ в хеше является 
именем символа (используется для всех объектов различных типов с тем же именем), значения 
в хеш-таблице представляют собой GV (Glob Value).  GV, в свою очередь, содержит сылки на объекты
различных типов, включая следующие (есть и другие типы):

    Scalar Value
    Array Value
    Hash Value
    I/O Handle
    Format
    Subroutine

Сущности пакета C<main> находятся в глобальном хеше C<PL_defstash>.  Для доступа к элементам других
пакетов используется имя пакета с добавлением символов '::'.  Для элементов пакета C<Foo> это будет 
C<Foo::> в PL_defstash.  Элементы C<Bar::Baz> находятся в стеше C<Baz> стеша C<Bar>.

Получить указатель на стеш конкретного пакета можно при помощи следующих функций:

    HV*  gv_stashpv(const char* name, I32 flags)
    HV*  gv_stashsv(SV*, I32 flags)

Первая принимает литеральную строку, вторая использует строку из SV.  Помните, стеш является обычным
хешом, поэтому на выходе возвращается C<HV*>.  


The first function takes a literal string, the second uses the string stored
in the SV.  Remember that a stash is just a hash table, so you get back an
C<HV*>.  The C<flags> flag will create a new package if it is set to GV_ADD.

The name that C<gv_stash*v> wants is the name of the package whose symbol table
you want.  The default package is called C<main>.  If you have multiply nested
packages, pass their names to C<gv_stash*v>, separated by C<::> as in the Perl
language itself.

Alternately, if you have an SV that is a blessed reference, you can find
out the stash pointer by using:

    HV*  SvSTASH(SvRV(SV*));

then use the following to get the package name itself:

    char*  HvNAME(HV* stash);

If you need to bless or re-bless an object you can use the following
function:

    SV*  sv_bless(SV*, HV* stash)

where the first argument, an C<SV*>, must be a reference, and the second
argument is a stash.  The returned C<SV*> can now be used in the same way
as any other SV.

For more information on references and blessings, consult L<perlref>.

=head2 Double-Typed SVs

Scalar variables normally contain only one type of value, an integer,
double, pointer, or reference.  Perl will automatically convert the
actual scalar data from the stored type into the requested type.

Some scalar variables contain more than one type of scalar data.  For
example, the variable C<$!> contains either the numeric value of C<errno>
or its string equivalent from either C<strerror> or C<sys_errlist[]>.

To force multiple data values into an SV, you must do two things: use the
C<sv_set*v> routines to add the additional scalar type, then set a flag
so that Perl will believe it contains more than one type of data.  The
four macros to set the flags are:

	SvIOK_on
	SvNOK_on
	SvPOK_on
	SvROK_on

The particular macro you must use depends on which C<sv_set*v> routine
you called first.  This is because every C<sv_set*v> routine turns on
only the bit for the particular type of data being set, and turns off
all the rest.

For example, to create a new Perl variable called "dberror" that contains
both the numeric and descriptive string error values, you could use the
following code:

    extern int  dberror;
    extern char *dberror_list;

    SV* sv = get_sv("dberror", GV_ADD);
    sv_setiv(sv, (IV) dberror);
    sv_setpv(sv, dberror_list[dberror]);
    SvIOK_on(sv);

If the order of C<sv_setiv> and C<sv_setpv> had been reversed, then the
macro C<SvPOK_on> would need to be called instead of C<SvIOK_on>.

=head2 Magic Variables

[This section still under construction.  Ignore everything here.  Post no
bills.  Everything not permitted is forbidden.]

Any SV may be magical, that is, it has special features that a normal
SV does not have.  These features are stored in the SV structure in a
linked list of C<struct magic>'s, typedef'ed to C<MAGIC>.

    struct magic {
        MAGIC*      mg_moremagic;
        MGVTBL*     mg_virtual;
        U16         mg_private;
        char        mg_type;
        U8          mg_flags;
        I32         mg_len;
        SV*         mg_obj;
        char*       mg_ptr;
    };

Note this is current as of patchlevel 0, and could change at any time.

=head2 Assigning Magic

Perl adds magic to an SV using the sv_magic function:

  void sv_magic(SV* sv, SV* obj, int how, const char* name, I32 namlen);

The C<sv> argument is a pointer to the SV that is to acquire a new magical
feature.

If C<sv> is not already magical, Perl uses the C<SvUPGRADE> macro to
convert C<sv> to type C<SVt_PVMG>. Perl then continues by adding new magic
to the beginning of the linked list of magical features.  Any prior entry
of the same type of magic is deleted.  Note that this can be overridden,
and multiple instances of the same type of magic can be associated with an
SV.

The C<name> and C<namlen> arguments are used to associate a string with
the magic, typically the name of a variable. C<namlen> is stored in the
C<mg_len> field and if C<name> is non-null then either a C<savepvn> copy of
C<name> or C<name> itself is stored in the C<mg_ptr> field, depending on
whether C<namlen> is greater than zero or equal to zero respectively.  As a
special case, if C<(name && namlen == HEf_SVKEY)> then C<name> is assumed
to contain an C<SV*> and is stored as-is with its REFCNT incremented.

The sv_magic function uses C<how> to determine which, if any, predefined
"Magic Virtual Table" should be assigned to the C<mg_virtual> field.
See the L<Magic Virtual Tables> section below.  The C<how> argument is also
stored in the C<mg_type> field. The value of C<how> should be chosen
from the set of macros C<PERL_MAGIC_foo> found in F<perl.h>. Note that before
these macros were added, Perl internals used to directly use character
literals, so you may occasionally come across old code or documentation
referring to 'U' magic rather than C<PERL_MAGIC_uvar> for example.

The C<obj> argument is stored in the C<mg_obj> field of the C<MAGIC>
structure.  If it is not the same as the C<sv> argument, the reference
count of the C<obj> object is incremented.  If it is the same, or if
the C<how> argument is C<PERL_MAGIC_arylen>, or if it is a NULL pointer,
then C<obj> is merely stored, without the reference count being incremented.

See also C<sv_magicext> in L<perlapi> for a more flexible way to add magic
to an SV.

There is also a function to add magic to an C<HV>:

    void hv_magic(HV *hv, GV *gv, int how);

This simply calls C<sv_magic> and coerces the C<gv> argument into an C<SV>.

To remove the magic from an SV, call the function sv_unmagic:

    int sv_unmagic(SV *sv, int type);

The C<type> argument should be equal to the C<how> value when the C<SV>
was initially made magical.

However, note that C<sv_unmagic> removes all magic of a certain C<type> from the
C<SV>. If you want to remove only certain magic of a C<type> based on the magic
virtual table, use C<sv_unmagicext> instead:

    int sv_unmagicext(SV *sv, int type, MGVTBL *vtbl);

=head2 Magic Virtual Tables

The C<mg_virtual> field in the C<MAGIC> structure is a pointer to an
C<MGVTBL>, which is a structure of function pointers and stands for
"Magic Virtual Table" to handle the various operations that might be
applied to that variable.

The C<MGVTBL> has five (or sometimes eight) pointers to the following
routine types:

    int  (*svt_get)(SV* sv, MAGIC* mg);
    int  (*svt_set)(SV* sv, MAGIC* mg);
    U32  (*svt_len)(SV* sv, MAGIC* mg);
    int  (*svt_clear)(SV* sv, MAGIC* mg);
    int  (*svt_free)(SV* sv, MAGIC* mg);

    int  (*svt_copy)(SV *sv, MAGIC* mg, SV *nsv,
                                          const char *name, I32 namlen);
    int  (*svt_dup)(MAGIC *mg, CLONE_PARAMS *param);
    int  (*svt_local)(SV *nsv, MAGIC *mg);


This MGVTBL structure is set at compile-time in F<perl.h> and there are
currently 32 types.  These different structures contain pointers to various
routines that perform additional actions depending on which function is
being called.

   Function pointer    Action taken
   ----------------    ------------
   svt_get             Do something before the value of the SV is
                       retrieved.
   svt_set             Do something after the SV is assigned a value.
   svt_len             Report on the SV's length.
   svt_clear           Clear something the SV represents.
   svt_free            Free any extra storage associated with the SV.

   svt_copy            copy tied variable magic to a tied element
   svt_dup             duplicate a magic structure during thread cloning
   svt_local           copy magic to local value during 'local'

For instance, the MGVTBL structure called C<vtbl_sv> (which corresponds
to an C<mg_type> of C<PERL_MAGIC_sv>) contains:

    { magic_get, magic_set, magic_len, 0, 0 }

Thus, when an SV is determined to be magical and of type C<PERL_MAGIC_sv>,
if a get operation is being performed, the routine C<magic_get> is
called.  All the various routines for the various magical types begin
with C<magic_>.  NOTE: the magic routines are not considered part of
the Perl API, and may not be exported by the Perl library.

The last three slots are a recent addition, and for source code
compatibility they are only checked for if one of the three flags
MGf_COPY, MGf_DUP or MGf_LOCAL is set in mg_flags. This means that most
code can continue declaring a vtable as a 5-element value. These three are
currently used exclusively by the threading code, and are highly subject
to change.

The current kinds of Magic Virtual Tables are:

=for comment
This table is generated by regen/mg_vtable.pl.  Any changes made here
will be lost.

=for mg_vtable.pl begin

 mg_type
 (old-style char and macro)   MGVTBL         Type of magic
 --------------------------   ------         -------------
 \0 PERL_MAGIC_sv             vtbl_sv        Special scalar variable
 #  PERL_MAGIC_arylen         vtbl_arylen    Array length ($#ary)
 %  PERL_MAGIC_rhash          (none)         extra data for restricted
                                             hashes
 &  PERL_MAGIC_proto          (none)         my sub prototype CV
 .  PERL_MAGIC_pos            vtbl_pos       pos() lvalue
 :  PERL_MAGIC_symtab         (none)         extra data for symbol
                                             tables
 <  PERL_MAGIC_backref        vtbl_backref   for weak ref data
 @  PERL_MAGIC_arylen_p       (none)         to move arylen out of XPVAV
 B  PERL_MAGIC_bm             vtbl_regexp    Boyer-Moore 
                                             (fast string search)
 c  PERL_MAGIC_overload_table vtbl_ovrld     Holds overload table 
                                             (AMT) on stash
 D  PERL_MAGIC_regdata        vtbl_regdata   Regex match position data 
                                             (@+ and @- vars)
 d  PERL_MAGIC_regdatum       vtbl_regdatum  Regex match position data
                                             element
 E  PERL_MAGIC_env            vtbl_env       %ENV hash
 e  PERL_MAGIC_envelem        vtbl_envelem   %ENV hash element
 f  PERL_MAGIC_fm             vtbl_regexp    Formline 
                                             ('compiled' format)
 g  PERL_MAGIC_regex_global   vtbl_mglob     m//g target
 H  PERL_MAGIC_hints          vtbl_hints     %^H hash
 h  PERL_MAGIC_hintselem      vtbl_hintselem %^H hash element
 I  PERL_MAGIC_isa            vtbl_isa       @ISA array
 i  PERL_MAGIC_isaelem        vtbl_isaelem   @ISA array element
 k  PERL_MAGIC_nkeys          vtbl_nkeys     scalar(keys()) lvalue
 L  PERL_MAGIC_dbfile         (none)         Debugger %_<filename
 l  PERL_MAGIC_dbline         vtbl_dbline    Debugger %_<filename
                                             element
 N  PERL_MAGIC_shared         (none)         Shared between threads
 n  PERL_MAGIC_shared_scalar  (none)         Shared between threads
 o  PERL_MAGIC_collxfrm       vtbl_collxfrm  Locale transformation
 P  PERL_MAGIC_tied           vtbl_pack      Tied array or hash
 p  PERL_MAGIC_tiedelem       vtbl_packelem  Tied array or hash element
 q  PERL_MAGIC_tiedscalar     vtbl_packelem  Tied scalar or handle
 r  PERL_MAGIC_qr             vtbl_regexp    precompiled qr// regex
 S  PERL_MAGIC_sig            (none)         %SIG hash
 s  PERL_MAGIC_sigelem        vtbl_sigelem   %SIG hash element
 t  PERL_MAGIC_taint          vtbl_taint     Taintedness
 U  PERL_MAGIC_uvar           vtbl_uvar      Available for use by
                                             extensions
 u  PERL_MAGIC_uvar_elem      (none)         Reserved for use by
                                             extensions
 V  PERL_MAGIC_vstring        (none)         SV was vstring literal
 v  PERL_MAGIC_vec            vtbl_vec       vec() lvalue
 w  PERL_MAGIC_utf8           vtbl_utf8      Cached UTF-8 information
 x  PERL_MAGIC_substr         vtbl_substr    substr() lvalue
 y  PERL_MAGIC_defelem        vtbl_defelem   Shadow "foreach" iterator
                                             variable / smart parameter
                                             vivification
 ]  PERL_MAGIC_checkcall      vtbl_checkcall inlining/mutation of call
                                             to this CV
 ~  PERL_MAGIC_ext            (none)         Available for use by
                                             extensions

=for mg_vtable.pl end

When an uppercase and lowercase letter both exist in the table, then the
uppercase letter is typically used to represent some kind of composite type
(a list or a hash), and the lowercase letter is used to represent an element
of that composite type. Some internals code makes use of this case
relationship.  However, 'v' and 'V' (vec and v-string) are in no way related.

The C<PERL_MAGIC_ext> and C<PERL_MAGIC_uvar> magic types are defined
specifically for use by extensions and will not be used by perl itself.
Extensions can use C<PERL_MAGIC_ext> magic to 'attach' private information
to variables (typically objects).  This is especially useful because
there is no way for normal perl code to corrupt this private information
(unlike using extra elements of a hash object).

Similarly, C<PERL_MAGIC_uvar> magic can be used much like tie() to call a
C function any time a scalar's value is used or changed.  The C<MAGIC>'s
C<mg_ptr> field points to a C<ufuncs> structure:

    struct ufuncs {
        I32 (*uf_val)(pTHX_ IV, SV*);
        I32 (*uf_set)(pTHX_ IV, SV*);
        IV uf_index;
    };

When the SV is read from or written to, the C<uf_val> or C<uf_set>
function will be called with C<uf_index> as the first arg and a pointer to
the SV as the second.  A simple example of how to add C<PERL_MAGIC_uvar>
magic is shown below.  Note that the ufuncs structure is copied by
sv_magic, so you can safely allocate it on the stack.

    void
    Umagic(sv)
        SV *sv;
    PREINIT:
        struct ufuncs uf;
    CODE:
        uf.uf_val   = &my_get_fn;
        uf.uf_set   = &my_set_fn;
        uf.uf_index = 0;
        sv_magic(sv, 0, PERL_MAGIC_uvar, (char*)&uf, sizeof(uf));

Attaching C<PERL_MAGIC_uvar> to arrays is permissible but has no effect.

For hashes there is a specialized hook that gives control over hash
keys (but not values).  This hook calls C<PERL_MAGIC_uvar> 'get' magic
if the "set" function in the C<ufuncs> structure is NULL.  The hook
is activated whenever the hash is accessed with a key specified as
an C<SV> through the functions C<hv_store_ent>, C<hv_fetch_ent>,
C<hv_delete_ent>, and C<hv_exists_ent>.  Accessing the key as a string
through the functions without the C<..._ent> suffix circumvents the
hook.  See L<Hash::Util::FieldHash/GUTS> for a detailed description.

Note that because multiple extensions may be using C<PERL_MAGIC_ext>
or C<PERL_MAGIC_uvar> magic, it is important for extensions to take
extra care to avoid conflict.  Typically only using the magic on
objects blessed into the same class as the extension is sufficient.
For C<PERL_MAGIC_ext> magic, it is usually a good idea to define an
C<MGVTBL>, even if all its fields will be C<0>, so that individual
C<MAGIC> pointers can be identified as a particular kind of magic
using their magic virtual table. C<mg_findext> provides an easy way
to do that:

    STATIC MGVTBL my_vtbl = { 0, 0, 0, 0, 0, 0, 0, 0 };

    MAGIC *mg;
    if ((mg = mg_findext(sv, PERL_MAGIC_ext, &my_vtbl))) {
        /* this is really ours, not another module's PERL_MAGIC_ext */
        my_priv_data_t *priv = (my_priv_data_t *)mg->mg_ptr;
        ...
    }

Also note that the C<sv_set*()> and C<sv_cat*()> functions described
earlier do B<not> invoke 'set' magic on their targets.  This must
be done by the user either by calling the C<SvSETMAGIC()> macro after
calling these functions, or by using one of the C<sv_set*_mg()> or
C<sv_cat*_mg()> functions.  Similarly, generic C code must call the
C<SvGETMAGIC()> macro to invoke any 'get' magic if they use an SV
obtained from external sources in functions that don't handle magic.
See L<perlapi> for a description of these functions.
For example, calls to the C<sv_cat*()> functions typically need to be
followed by C<SvSETMAGIC()>, but they don't need a prior C<SvGETMAGIC()>
since their implementation handles 'get' magic.

=head2 Finding Magic

    MAGIC *mg_find(SV *sv, int type); /* Finds the magic pointer of that
                                       * type */

This routine returns a pointer to a C<MAGIC> structure stored in the SV.
If the SV does not have that magical feature, C<NULL> is returned. If the
SV has multiple instances of that magical feature, the first one will be
returned. C<mg_findext> can be used to find a C<MAGIC> structure of an SV
based on both its magic type and its magic virtual table:

    MAGIC *mg_findext(SV *sv, int type, MGVTBL *vtbl);

Also, if the SV passed to C<mg_find> or C<mg_findext> is not of type
SVt_PVMG, Perl may core dump.

    int mg_copy(SV* sv, SV* nsv, const char* key, STRLEN klen);

This routine checks to see what types of magic C<sv> has.  If the mg_type
field is an uppercase letter, then the mg_obj is copied to C<nsv>, but
the mg_type field is changed to be the lowercase letter.

=head2 Understanding the Magic of Tied Hashes and Arrays

Tied hashes and arrays are magical beasts of the C<PERL_MAGIC_tied>
magic type.

WARNING: As of the 5.004 release, proper usage of the array and hash
access functions requires understanding a few caveats.  Some
of these caveats are actually considered bugs in the API, to be fixed
in later releases, and are bracketed with [MAYCHANGE] below. If
you find yourself actually applying such information in this section, be
aware that the behavior may change in the future, umm, without warning.

The perl tie function associates a variable with an object that implements
the various GET, SET, etc methods.  To perform the equivalent of the perl
tie function from an XSUB, you must mimic this behaviour.  The code below
carries out the necessary steps - firstly it creates a new hash, and then
creates a second hash which it blesses into the class which will implement
the tie methods. Lastly it ties the two hashes together, and returns a
reference to the new tied hash.  Note that the code below does NOT call the
TIEHASH method in the MyTie class -
see L<Calling Perl Routines from within C Programs> for details on how
to do this.

    SV*
    mytie()
    PREINIT:
        HV *hash;
        HV *stash;
        SV *tie;
    CODE:
        hash = newHV();
        tie = newRV_noinc((SV*)newHV());
        stash = gv_stashpv("MyTie", GV_ADD);
        sv_bless(tie, stash);
        hv_magic(hash, (GV*)tie, PERL_MAGIC_tied);
        RETVAL = newRV_noinc(hash);
    OUTPUT:
        RETVAL

The C<av_store> function, when given a tied array argument, merely
copies the magic of the array onto the value to be "stored", using
C<mg_copy>.  It may also return NULL, indicating that the value did not
actually need to be stored in the array.  [MAYCHANGE] After a call to
C<av_store> on a tied array, the caller will usually need to call
C<mg_set(val)> to actually invoke the perl level "STORE" method on the
TIEARRAY object.  If C<av_store> did return NULL, a call to
C<SvREFCNT_dec(val)> will also be usually necessary to avoid a memory
leak. [/MAYCHANGE]

The previous paragraph is applicable verbatim to tied hash access using the
C<hv_store> and C<hv_store_ent> functions as well.

C<av_fetch> and the corresponding hash functions C<hv_fetch> and
C<hv_fetch_ent> actually return an undefined mortal value whose magic
has been initialized using C<mg_copy>.  Note the value so returned does not
need to be deallocated, as it is already mortal.  [MAYCHANGE] But you will
need to call C<mg_get()> on the returned value in order to actually invoke
the perl level "FETCH" method on the underlying TIE object.  Similarly,
you may also call C<mg_set()> on the return value after possibly assigning
a suitable value to it using C<sv_setsv>,  which will invoke the "STORE"
method on the TIE object. [/MAYCHANGE]

[MAYCHANGE]
In other words, the array or hash fetch/store functions don't really
fetch and store actual values in the case of tied arrays and hashes.  They
merely call C<mg_copy> to attach magic to the values that were meant to be
"stored" or "fetched".  Later calls to C<mg_get> and C<mg_set> actually
do the job of invoking the TIE methods on the underlying objects.  Thus
the magic mechanism currently implements a kind of lazy access to arrays
and hashes.

Currently (as of perl version 5.004), use of the hash and array access
functions requires the user to be aware of whether they are operating on
"normal" hashes and arrays, or on their tied variants.  The API may be
changed to provide more transparent access to both tied and normal data
types in future versions.
[/MAYCHANGE]

You would do well to understand that the TIEARRAY and TIEHASH interfaces
are mere sugar to invoke some perl method calls while using the uniform hash
and array syntax.  The use of this sugar imposes some overhead (typically
about two to four extra opcodes per FETCH/STORE operation, in addition to
the creation of all the mortal variables required to invoke the methods).
This overhead will be comparatively small if the TIE methods are themselves
substantial, but if they are only a few statements long, the overhead
will not be insignificant.

=head2 Localizing changes

Perl has a very handy construction

  {
    local $var = 2;
    ...
  }

This construction is I<approximately> equivalent to

  {
    my $oldvar = $var;
    $var = 2;
    ...
    $var = $oldvar;
  }

The biggest difference is that the first construction would
reinstate the initial value of $var, irrespective of how control exits
the block: C<goto>, C<return>, C<die>/C<eval>, etc. It is a little bit
more efficient as well.

There is a way to achieve a similar task from C via Perl API: create a
I<pseudo-block>, and arrange for some changes to be automatically
undone at the end of it, either explicit, or via a non-local exit (via
die()). A I<block>-like construct is created by a pair of
C<ENTER>/C<LEAVE> macros (see L<perlcall/"Returning a Scalar">).
Such a construct may be created specially for some important localized
task, or an existing one (like boundaries of enclosing Perl
subroutine/block, or an existing pair for freeing TMPs) may be
used. (In the second case the overhead of additional localization must
be almost negligible.) Note that any XSUB is automatically enclosed in
an C<ENTER>/C<LEAVE> pair.

Inside such a I<pseudo-block> the following service is available:

=over 4

=item C<SAVEINT(int i)>

=item C<SAVEIV(IV i)>

=item C<SAVEI32(I32 i)>

=item C<SAVELONG(long i)>

These macros arrange things to restore the value of integer variable
C<i> at the end of enclosing I<pseudo-block>.

=item C<SAVESPTR(s)>

=item C<SAVEPPTR(p)>

These macros arrange things to restore the value of pointers C<s> and
C<p>. C<s> must be a pointer of a type which survives conversion to
C<SV*> and back, C<p> should be able to survive conversion to C<char*>
and back.

=item C<SAVEFREESV(SV *sv)>

The refcount of C<sv> would be decremented at the end of
I<pseudo-block>.  This is similar to C<sv_2mortal> in that it is also a
mechanism for doing a delayed C<SvREFCNT_dec>.  However, while C<sv_2mortal>
extends the lifetime of C<sv> until the beginning of the next statement,
C<SAVEFREESV> extends it until the end of the enclosing scope.  These
lifetimes can be wildly different.

Also compare C<SAVEMORTALIZESV>.

=item C<SAVEMORTALIZESV(SV *sv)>

Just like C<SAVEFREESV>, but mortalizes C<sv> at the end of the current
scope instead of decrementing its reference count.  This usually has the
effect of keeping C<sv> alive until the statement that called the currently
live scope has finished executing.

=item C<SAVEFREEOP(OP *op)>

The C<OP *> is op_free()ed at the end of I<pseudo-block>.

=item C<SAVEFREEPV(p)>

The chunk of memory which is pointed to by C<p> is Safefree()ed at the
end of I<pseudo-block>.

=item C<SAVECLEARSV(SV *sv)>

Clears a slot in the current scratchpad which corresponds to C<sv> at
the end of I<pseudo-block>.

=item C<SAVEDELETE(HV *hv, char *key, I32 length)>

The key C<key> of C<hv> is deleted at the end of I<pseudo-block>. The
string pointed to by C<key> is Safefree()ed.  If one has a I<key> in
short-lived storage, the corresponding string may be reallocated like
this:

  SAVEDELETE(PL_defstash, savepv(tmpbuf), strlen(tmpbuf));

=item C<SAVEDESTRUCTOR(DESTRUCTORFUNC_NOCONTEXT_t f, void *p)>

At the end of I<pseudo-block> the function C<f> is called with the
only argument C<p>.

=item C<SAVEDESTRUCTOR_X(DESTRUCTORFUNC_t f, void *p)>

At the end of I<pseudo-block> the function C<f> is called with the
implicit context argument (if any), and C<p>.

=item C<SAVESTACK_POS()>

The current offset on the Perl internal stack (cf. C<SP>) is restored
at the end of I<pseudo-block>.

=back

The following API list contains functions, thus one needs to
provide pointers to the modifiable data explicitly (either C pointers,
or Perlish C<GV *>s).  Where the above macros take C<int>, a similar
function takes C<int *>.

=over 4

=item C<SV* save_scalar(GV *gv)>

Equivalent to Perl code C<local $gv>.

=item C<AV* save_ary(GV *gv)>

=item C<HV* save_hash(GV *gv)>

Similar to C<save_scalar>, but localize C<@gv> and C<%gv>.

=item C<void save_item(SV *item)>

Duplicates the current value of C<SV>, on the exit from the current
C<ENTER>/C<LEAVE> I<pseudo-block> will restore the value of C<SV>
using the stored value. It doesn't handle magic. Use C<save_scalar> if
magic is affected.

=item C<void save_list(SV **sarg, I32 maxsarg)>

A variant of C<save_item> which takes multiple arguments via an array
C<sarg> of C<SV*> of length C<maxsarg>.

=item C<SV* save_svref(SV **sptr)>

Similar to C<save_scalar>, but will reinstate an C<SV *>.

=item C<void save_aptr(AV **aptr)>

=item C<void save_hptr(HV **hptr)>

Similar to C<save_svref>, but localize C<AV *> and C<HV *>.

=back

The C<Alias> module implements localization of the basic types within the
I<caller's scope>.  People who are interested in how to localize things in
the containing scope should take a look there too.

=head1 Subroutines

=head2 XSUBs and the Argument Stack

The XSUB mechanism is a simple way for Perl programs to access C subroutines.
An XSUB routine will have a stack that contains the arguments from the Perl
program, and a way to map from the Perl data structures to a C equivalent.

The stack arguments are accessible through the C<ST(n)> macro, which returns
the C<n>'th stack argument.  Argument 0 is the first argument passed in the
Perl subroutine call.  These arguments are C<SV*>, and can be used anywhere
an C<SV*> is used.

Most of the time, output from the C routine can be handled through use of
the RETVAL and OUTPUT directives.  However, there are some cases where the
argument stack is not already long enough to handle all the return values.
An example is the POSIX tzname() call, which takes no arguments, but returns
two, the local time zone's standard and summer time abbreviations.

To handle this situation, the PPCODE directive is used and the stack is
extended using the macro:

    EXTEND(SP, num);

where C<SP> is the macro that represents the local copy of the stack pointer,
and C<num> is the number of elements the stack should be extended by.

Now that there is room on the stack, values can be pushed on it using C<PUSHs>
macro. The pushed values will often need to be "mortal" (See
L</Reference Counts and Mortality>):

    PUSHs(sv_2mortal(newSViv(an_integer)))
    PUSHs(sv_2mortal(newSVuv(an_unsigned_integer)))
    PUSHs(sv_2mortal(newSVnv(a_double)))
    PUSHs(sv_2mortal(newSVpv("Some String",0)))
    /* Although the last example is better written as the more
     * efficient: */
    PUSHs(newSVpvs_flags("Some String", SVs_TEMP))

And now the Perl program calling C<tzname>, the two values will be assigned
as in:

    ($standard_abbrev, $summer_abbrev) = POSIX::tzname;

An alternate (and possibly simpler) method to pushing values on the stack is
to use the macro:

    XPUSHs(SV*)

This macro automatically adjusts the stack for you, if needed.  Thus, you
do not need to call C<EXTEND> to extend the stack.

Despite their suggestions in earlier versions of this document the macros
C<(X)PUSH[iunp]> are I<not> suited to XSUBs which return multiple results.
For that, either stick to the C<(X)PUSHs> macros shown above, or use the new
C<m(X)PUSH[iunp]> macros instead; see L</Putting a C value on Perl stack>.

For more information, consult L<perlxs> and L<perlxstut>.

=head2 Autoloading with XSUBs

If an AUTOLOAD routine is an XSUB, as with Perl subroutines, Perl puts the
fully-qualified name of the autoloaded subroutine in the $AUTOLOAD variable
of the XSUB's package.

But it also puts the same information in certain fields of the XSUB itself:

    HV *stash           = CvSTASH(cv);
    const char *subname = SvPVX(cv);
    STRLEN name_length  = SvCUR(cv); /* in bytes */
    U32 is_utf8         = SvUTF8(cv);

C<SvPVX(cv)> contains just the sub name itself, not including the package.
For an AUTOLOAD routine in UNIVERSAL or one of its superclasses,
C<CvSTASH(cv)> returns NULL during a method call on a nonexistent package.

B<Note>: Setting $AUTOLOAD stopped working in 5.6.1, which did not support
XS AUTOLOAD subs at all.  Perl 5.8.0 introduced the use of fields in the
XSUB itself.  Perl 5.16.0 restored the setting of $AUTOLOAD.  If you need
to support 5.8-5.14, use the XSUB's fields.

=head2 Calling Perl Routines from within C Programs

There are four routines that can be used to call a Perl subroutine from
within a C program.  These four are:

    I32  call_sv(SV*, I32);
    I32  call_pv(const char*, I32);
    I32  call_method(const char*, I32);
    I32  call_argv(const char*, I32, char**);

The routine most often used is C<call_sv>.  The C<SV*> argument
contains either the name of the Perl subroutine to be called, or a
reference to the subroutine.  The second argument consists of flags
that control the context in which the subroutine is called, whether
or not the subroutine is being passed arguments, how errors should be
trapped, and how to treat return values.

All four routines return the number of arguments that the subroutine returned
on the Perl stack.

These routines used to be called C<perl_call_sv>, etc., before Perl v5.6.0,
but those names are now deprecated; macros of the same name are provided for
compatibility.

When using any of these routines (except C<call_argv>), the programmer
must manipulate the Perl stack.  These include the following macros and
functions:

    dSP
    SP
    PUSHMARK()
    PUTBACK
    SPAGAIN
    ENTER
    SAVETMPS
    FREETMPS
    LEAVE
    XPUSH*()
    POP*()

For a detailed description of calling conventions from C to Perl,
consult L<perlcall>.

=head2 Memory Allocation

=head3 Allocation

All memory meant to be used with the Perl API functions should be manipulated
using the macros described in this section.  The macros provide the necessary
transparency between differences in the actual malloc implementation that is
used within perl.

It is suggested that you enable the version of malloc that is distributed
with Perl.  It keeps pools of various sizes of unallocated memory in
order to satisfy allocation requests more quickly.  However, on some
platforms, it may cause spurious malloc or free errors.

The following three macros are used to initially allocate memory :

    Newx(pointer, number, type);
    Newxc(pointer, number, type, cast);
    Newxz(pointer, number, type);

The first argument C<pointer> should be the name of a variable that will
point to the newly allocated memory.

The second and third arguments C<number> and C<type> specify how many of
the specified type of data structure should be allocated.  The argument
C<type> is passed to C<sizeof>.  The final argument to C<Newxc>, C<cast>,
should be used if the C<pointer> argument is different from the C<type>
argument.

Unlike the C<Newx> and C<Newxc> macros, the C<Newxz> macro calls C<memzero>
to zero out all the newly allocated memory.

=head3 Reallocation

    Renew(pointer, number, type);
    Renewc(pointer, number, type, cast);
    Safefree(pointer)

These three macros are used to change a memory buffer size or to free a
piece of memory no longer needed.  The arguments to C<Renew> and C<Renewc>
match those of C<New> and C<Newc> with the exception of not needing the
"magic cookie" argument.

=head3 Moving

    Move(source, dest, number, type);
    Copy(source, dest, number, type);
    Zero(dest, number, type);

These three macros are used to move, copy, or zero out previously allocated
memory.  The C<source> and C<dest> arguments point to the source and
destination starting points.  Perl will move, copy, or zero out C<number>
instances of the size of the C<type> data structure (using the C<sizeof>
function).

=head2 PerlIO

The most recent development releases of Perl have been experimenting with
removing Perl's dependency on the "normal" standard I/O suite and allowing
other stdio implementations to be used.  This involves creating a new
abstraction layer that then calls whichever implementation of stdio Perl
was compiled with.  All XSUBs should now use the functions in the PerlIO
abstraction layer and not make any assumptions about what kind of stdio
is being used.

For a complete description of the PerlIO abstraction, consult L<perlapio>.

=head2 Putting a C value on Perl stack

A lot of opcodes (this is an elementary operation in the internal perl
stack machine) put an SV* on the stack. However, as an optimization
the corresponding SV is (usually) not recreated each time. The opcodes
reuse specially assigned SVs (I<target>s) which are (as a corollary)
not constantly freed/created.

Each of the targets is created only once (but see
L<Scratchpads and recursion> below), and when an opcode needs to put
an integer, a double, or a string on stack, it just sets the
corresponding parts of its I<target> and puts the I<target> on stack.

The macro to put this target on stack is C<PUSHTARG>, and it is
directly used in some opcodes, as well as indirectly in zillions of
others, which use it via C<(X)PUSH[iunp]>.

Because the target is reused, you must be careful when pushing multiple
values on the stack. The following code will not do what you think:

    XPUSHi(10);
    XPUSHi(20);

This translates as "set C<TARG> to 10, push a pointer to C<TARG> onto
the stack; set C<TARG> to 20, push a pointer to C<TARG> onto the stack".
At the end of the operation, the stack does not contain the values 10
and 20, but actually contains two pointers to C<TARG>, which we have set
to 20.

If you need to push multiple different values then you should either use
the C<(X)PUSHs> macros, or else use the new C<m(X)PUSH[iunp]> macros,
none of which make use of C<TARG>.  The C<(X)PUSHs> macros simply push an
SV* on the stack, which, as noted under L</XSUBs and the Argument Stack>,
will often need to be "mortal".  The new C<m(X)PUSH[iunp]> macros make
this a little easier to achieve by creating a new mortal for you (via
C<(X)PUSHmortal>), pushing that onto the stack (extending it if necessary
in the case of the C<mXPUSH[iunp]> macros), and then setting its value.
Thus, instead of writing this to "fix" the example above:

    XPUSHs(sv_2mortal(newSViv(10)))
    XPUSHs(sv_2mortal(newSViv(20)))

you can simply write:

    mXPUSHi(10)
    mXPUSHi(20)

On a related note, if you do use C<(X)PUSH[iunp]>, then you're going to
need a C<dTARG> in your variable declarations so that the C<*PUSH*>
macros can make use of the local variable C<TARG>.  See also C<dTARGET>
and C<dXSTARG>.

=head2 Scratchpads

The question remains on when the SVs which are I<target>s for opcodes
are created. The answer is that they are created when the current
unit--a subroutine or a file (for opcodes for statements outside of
subroutines)--is compiled. During this time a special anonymous Perl
array is created, which is called a scratchpad for the current unit.

A scratchpad keeps SVs which are lexicals for the current unit and are
targets for opcodes. One can deduce that an SV lives on a scratchpad
by looking on its flags: lexicals have C<SVs_PADMY> set, and
I<target>s have C<SVs_PADTMP> set.

The correspondence between OPs and I<target>s is not 1-to-1. Different
OPs in the compile tree of the unit can use the same target, if this
would not conflict with the expected life of the temporary.

=head2 Scratchpads and recursion

In fact it is not 100% true that a compiled unit contains a pointer to
the scratchpad AV. In fact it contains a pointer to an AV of
(initially) one element, and this element is the scratchpad AV. Why do
we need an extra level of indirection?

The answer is B<recursion>, and maybe B<threads>. Both
these can create several execution pointers going into the same
subroutine. For the subroutine-child not write over the temporaries
for the subroutine-parent (lifespan of which covers the call to the
child), the parent and the child should have different
scratchpads. (I<And> the lexicals should be separate anyway!)

So each subroutine is born with an array of scratchpads (of length 1).
On each entry to the subroutine it is checked that the current
depth of the recursion is not more than the length of this array, and
if it is, new scratchpad is created and pushed into the array.

The I<target>s on this scratchpad are C<undef>s, but they are already
marked with correct flags.

=head1 Compiled code

=head2 Code tree

Here we describe the internal form your code is converted to by
Perl. Start with a simple example:

  $a = $b + $c;

This is converted to a tree similar to this one:

             assign-to
           /           \
          +             $a
        /   \
      $b     $c

(but slightly more complicated).  This tree reflects the way Perl
parsed your code, but has nothing to do with the execution order.
There is an additional "thread" going through the nodes of the tree
which shows the order of execution of the nodes.  In our simplified
example above it looks like:

     $b ---> $c ---> + ---> $a ---> assign-to

But with the actual compile tree for C<$a = $b + $c> it is different:
some nodes I<optimized away>.  As a corollary, though the actual tree
contains more nodes than our simplified example, the execution order
is the same as in our example.

=head2 Examining the tree

If you have your perl compiled for debugging (usually done with
C<-DDEBUGGING> on the C<Configure> command line), you may examine the
compiled tree by specifying C<-Dx> on the Perl command line.  The
output takes several lines per node, and for C<$b+$c> it looks like
this:

    5           TYPE = add  ===> 6
                TARG = 1
                FLAGS = (SCALAR,KIDS)
                {
                    TYPE = null  ===> (4)
                      (was rv2sv)
                    FLAGS = (SCALAR,KIDS)
                    {
    3                   TYPE = gvsv  ===> 4
                        FLAGS = (SCALAR)
                        GV = main::b
                    }
                }
                {
                    TYPE = null  ===> (5)
                      (was rv2sv)
                    FLAGS = (SCALAR,KIDS)
                    {
    4                   TYPE = gvsv  ===> 5
                        FLAGS = (SCALAR)
                        GV = main::c
                    }
                }

This tree has 5 nodes (one per C<TYPE> specifier), only 3 of them are
not optimized away (one per number in the left column).  The immediate
children of the given node correspond to C<{}> pairs on the same level
of indentation, thus this listing corresponds to the tree:

                   add
                 /     \
               null    null
                |       |
               gvsv    gvsv

The execution order is indicated by C<===E<gt>> marks, thus it is C<3
4 5 6> (node C<6> is not included into above listing), i.e.,
C<gvsv gvsv add whatever>.

Each of these nodes represents an op, a fundamental operation inside the
Perl core. The code which implements each operation can be found in the
F<pp*.c> files; the function which implements the op with type C<gvsv>
is C<pp_gvsv>, and so on. As the tree above shows, different ops have
different numbers of children: C<add> is a binary operator, as one would
expect, and so has two children. To accommodate the various different
numbers of children, there are various types of op data structure, and
they link together in different ways.

The simplest type of op structure is C<OP>: this has no children. Unary
operators, C<UNOP>s, have one child, and this is pointed to by the
C<op_first> field. Binary operators (C<BINOP>s) have not only an
C<op_first> field but also an C<op_last> field. The most complex type of
op is a C<LISTOP>, which has any number of children. In this case, the
first child is pointed to by C<op_first> and the last child by
C<op_last>. The children in between can be found by iteratively
following the C<op_sibling> pointer from the first child to the last.

There are also two other op types: a C<PMOP> holds a regular expression,
and has no children, and a C<LOOP> may or may not have children. If the
C<op_children> field is non-zero, it behaves like a C<LISTOP>. To
complicate matters, if a C<UNOP> is actually a C<null> op after
optimization (see L</Compile pass 2: context propagation>) it will still
have children in accordance with its former type.

Another way to examine the tree is to use a compiler back-end module, such
as L<B::Concise>.

=head2 Compile pass 1: check routines

The tree is created by the compiler while I<yacc> code feeds it
the constructions it recognizes. Since I<yacc> works bottom-up, so does
the first pass of perl compilation.

What makes this pass interesting for perl developers is that some
optimization may be performed on this pass.  This is optimization by
so-called "check routines".  The correspondence between node names
and corresponding check routines is described in F<opcode.pl> (do not
forget to run C<make regen_headers> if you modify this file).

A check routine is called when the node is fully constructed except
for the execution-order thread.  Since at this time there are no
back-links to the currently constructed node, one can do most any
operation to the top-level node, including freeing it and/or creating
new nodes above/below it.

The check routine returns the node which should be inserted into the
tree (if the top-level node was not modified, check routine returns
its argument).

By convention, check routines have names C<ck_*>. They are usually
called from C<new*OP> subroutines (or C<convert>) (which in turn are
called from F<perly.y>).

=head2 Compile pass 1a: constant folding

Immediately after the check routine is called the returned node is
checked for being compile-time executable.  If it is (the value is
judged to be constant) it is immediately executed, and a I<constant>
node with the "return value" of the corresponding subtree is
substituted instead.  The subtree is deleted.

If constant folding was not performed, the execution-order thread is
created.

=head2 Compile pass 2: context propagation

When a context for a part of compile tree is known, it is propagated
down through the tree.  At this time the context can have 5 values
(instead of 2 for runtime context): void, boolean, scalar, list, and
lvalue.  In contrast with the pass 1 this pass is processed from top
to bottom: a node's context determines the context for its children.

Additional context-dependent optimizations are performed at this time.
Since at this moment the compile tree contains back-references (via
"thread" pointers), nodes cannot be free()d now.  To allow
optimized-away nodes at this stage, such nodes are null()ified instead
of free()ing (i.e. their type is changed to OP_NULL).

=head2 Compile pass 3: peephole optimization

After the compile tree for a subroutine (or for an C<eval> or a file)
is created, an additional pass over the code is performed. This pass
is neither top-down or bottom-up, but in the execution order (with
additional complications for conditionals).  Optimizations performed
at this stage are subject to the same restrictions as in the pass 2.

Peephole optimizations are done by calling the function pointed to
by the global variable C<PL_peepp>.  By default, C<PL_peepp> just
calls the function pointed to by the global variable C<PL_rpeepp>.
By default, that performs some basic op fixups and optimisations along
the execution-order op chain, and recursively calls C<PL_rpeepp> for
each side chain of ops (resulting from conditionals).  Extensions may
provide additional optimisations or fixups, hooking into either the
per-subroutine or recursive stage, like this:

    static peep_t prev_peepp;
    static void my_peep(pTHX_ OP *o)
    {
        /* custom per-subroutine optimisation goes here */
        prev_peepp(aTHX_ o);
        /* custom per-subroutine optimisation may also go here */
    }
    BOOT:
        prev_peepp = PL_peepp;
        PL_peepp = my_peep;

    static peep_t prev_rpeepp;
    static void my_rpeep(pTHX_ OP *o)
    {
        OP *orig_o = o;
        for(; o; o = o->op_next) {
            /* custom per-op optimisation goes here */
        }
        prev_rpeepp(aTHX_ orig_o);
    }
    BOOT:
        prev_rpeepp = PL_rpeepp;
        PL_rpeepp = my_rpeep;

=head2 Pluggable runops

The compile tree is executed in a runops function.  There are two runops
functions, in F<run.c> and in F<dump.c>.  C<Perl_runops_debug> is used
with DEBUGGING and C<Perl_runops_standard> is used otherwise.  For fine
control over the execution of the compile tree it is possible to provide
your own runops function.

It's probably best to copy one of the existing runops functions and
change it to suit your needs.  Then, in the BOOT section of your XS
file, add the line:

  PL_runops = my_runops;

This function should be as efficient as possible to keep your programs
running as fast as possible.

=head2 Compile-time scope hooks

As of perl 5.14 it is possible to hook into the compile-time lexical
scope mechanism using C<Perl_blockhook_register>. This is used like
this:

    STATIC void my_start_hook(pTHX_ int full);
    STATIC BHK my_hooks;

    BOOT:
        BhkENTRY_set(&my_hooks, bhk_start, my_start_hook);
        Perl_blockhook_register(aTHX_ &my_hooks);

This will arrange to have C<my_start_hook> called at the start of
compiling every lexical scope. The available hooks are:

=over 4

=item C<void bhk_start(pTHX_ int full)>

This is called just after starting a new lexical scope. Note that Perl
code like

    if ($x) { ... }

creates two scopes: the first starts at the C<(> and has C<full == 1>,
the second starts at the C<{> and has C<full == 0>. Both end at the
C<}>, so calls to C<start> and C<pre/post_end> will match. Anything
pushed onto the save stack by this hook will be popped just before the
scope ends (between the C<pre_> and C<post_end> hooks, in fact).

=item C<void bhk_pre_end(pTHX_ OP **o)>

This is called at the end of a lexical scope, just before unwinding the
stack. I<o> is the root of the optree representing the scope; it is a
double pointer so you can replace the OP if you need to.

=item C<void bhk_post_end(pTHX_ OP **o)>

This is called at the end of a lexical scope, just after unwinding the
stack. I<o> is as above. Note that it is possible for calls to C<pre_>
and C<post_end> to nest, if there is something on the save stack that
calls string eval.

=item C<void bhk_eval(pTHX_ OP *const o)>

This is called just before starting to compile an C<eval STRING>, C<do
FILE>, C<require> or C<use>, after the eval has been set up. I<o> is the
OP that requested the eval, and will normally be an C<OP_ENTEREVAL>,
C<OP_DOFILE> or C<OP_REQUIRE>.

=back

Once you have your hook functions, you need a C<BHK> structure to put
them in. It's best to allocate it statically, since there is no way to
free it once it's registered. The function pointers should be inserted
into this structure using the C<BhkENTRY_set> macro, which will also set
flags indicating which entries are valid. If you do need to allocate
your C<BHK> dynamically for some reason, be sure to zero it before you
start.

Once registered, there is no mechanism to switch these hooks off, so if
that is necessary you will need to do this yourself. An entry in C<%^H>
is probably the best way, so the effect is lexically scoped; however it
is also possible to use the C<BhkDISABLE> and C<BhkENABLE> macros to
temporarily switch entries on and off. You should also be aware that
generally speaking at least one scope will have opened before your
extension is loaded, so you will see some C<pre/post_end> pairs that
didn't have a matching C<start>.

=head1 Examining internal data structures with the C<dump> functions

To aid debugging, the source file F<dump.c> contains a number of
functions which produce formatted output of internal data structures.

The most commonly used of these functions is C<Perl_sv_dump>; it's used
for dumping SVs, AVs, HVs, and CVs. The C<Devel::Peek> module calls
C<sv_dump> to produce debugging output from Perl-space, so users of that
module should already be familiar with its format.

C<Perl_op_dump> can be used to dump an C<OP> structure or any of its
derivatives, and produces output similar to C<perl -Dx>; in fact,
C<Perl_dump_eval> will dump the main root of the code being evaluated,
exactly like C<-Dx>.

Other useful functions are C<Perl_dump_sub>, which turns a C<GV> into an
op tree, C<Perl_dump_packsubs> which calls C<Perl_dump_sub> on all the
subroutines in a package like so: (Thankfully, these are all xsubs, so
there is no op tree)

    (gdb) print Perl_dump_packsubs(PL_defstash)

    SUB attributes::bootstrap = (xsub 0x811fedc 0)

    SUB UNIVERSAL::can = (xsub 0x811f50c 0)

    SUB UNIVERSAL::isa = (xsub 0x811f304 0)

    SUB UNIVERSAL::VERSION = (xsub 0x811f7ac 0)

    SUB DynaLoader::boot_DynaLoader = (xsub 0x805b188 0)

and C<Perl_dump_all>, which dumps all the subroutines in the stash and
the op tree of the main root.

=head1 How multiple interpreters and concurrency are supported

=head2 Background and PERL_IMPLICIT_CONTEXT

The Perl interpreter can be regarded as a closed box: it has an API
for feeding it code or otherwise making it do things, but it also has
functions for its own use.  This smells a lot like an object, and
there are ways for you to build Perl so that you can have multiple
interpreters, with one interpreter represented either as a C structure,
or inside a thread-specific structure.  These structures contain all
the context, the state of that interpreter.

One macro controls the major Perl build flavor: MULTIPLICITY. The
MULTIPLICITY build has a C structure that packages all the interpreter
state. With multiplicity-enabled perls, PERL_IMPLICIT_CONTEXT is also
normally defined, and enables the support for passing in a "hidden" first
argument that represents all three data structures. MULTIPLICITY makes
multi-threaded perls possible (with the ithreads threading model, related
to the macro USE_ITHREADS.)

Two other "encapsulation" macros are the PERL_GLOBAL_STRUCT and
PERL_GLOBAL_STRUCT_PRIVATE (the latter turns on the former, and the
former turns on MULTIPLICITY.)  The PERL_GLOBAL_STRUCT causes all the
internal variables of Perl to be wrapped inside a single global struct,
struct perl_vars, accessible as (globals) &PL_Vars or PL_VarsPtr or
the function  Perl_GetVars().  The PERL_GLOBAL_STRUCT_PRIVATE goes
one step further, there is still a single struct (allocated in main()
either from heap or from stack) but there are no global data symbols
pointing to it.  In either case the global struct should be initialised
as the very first thing in main() using Perl_init_global_struct() and
correspondingly tear it down after perl_free() using Perl_free_global_struct(),
please see F<miniperlmain.c> for usage details.  You may also need
to use C<dVAR> in your coding to "declare the global variables"
when you are using them.  dTHX does this for you automatically.

To see whether you have non-const data you can use a BSD-compatible C<nm>:

  nm libperl.a | grep -v ' [TURtr] '

If this displays any C<D> or C<d> symbols, you have non-const data.

For backward compatibility reasons defining just PERL_GLOBAL_STRUCT
doesn't actually hide all symbols inside a big global struct: some
PerlIO_xxx vtables are left visible.  The PERL_GLOBAL_STRUCT_PRIVATE
then hides everything (see how the PERLIO_FUNCS_DECL is used).

All this obviously requires a way for the Perl internal functions to be
either subroutines taking some kind of structure as the first
argument, or subroutines taking nothing as the first argument.  To
enable these two very different ways of building the interpreter,
the Perl source (as it does in so many other situations) makes heavy
use of macros and subroutine naming conventions.

First problem: deciding which functions will be public API functions and
which will be private.  All functions whose names begin C<S_> are private
(think "S" for "secret" or "static").  All other functions begin with
"Perl_", but just because a function begins with "Perl_" does not mean it is
part of the API. (See L</Internal Functions>.) The easiest way to be B<sure> a
function is part of the API is to find its entry in L<perlapi>.
If it exists in L<perlapi>, it's part of the API.  If it doesn't, and you
think it should be (i.e., you need it for your extension), send mail via
L<perlbug> explaining why you think it should be.

Second problem: there must be a syntax so that the same subroutine
declarations and calls can pass a structure as their first argument,
or pass nothing.  To solve this, the subroutines are named and
declared in a particular way.  Here's a typical start of a static
function used within the Perl guts:

  STATIC void
  S_incline(pTHX_ char *s)

STATIC becomes "static" in C, and may be #define'd to nothing in some
configurations in the future.

A public function (i.e. part of the internal API, but not necessarily
sanctioned for use in extensions) begins like this:

  void
  Perl_sv_setiv(pTHX_ SV* dsv, IV num)

C<pTHX_> is one of a number of macros (in F<perl.h>) that hide the
details of the interpreter's context.  THX stands for "thread", "this",
or "thingy", as the case may be.  (And no, George Lucas is not involved. :-)
The first character could be 'p' for a B<p>rototype, 'a' for B<a>rgument,
or 'd' for B<d>eclaration, so we have C<pTHX>, C<aTHX> and C<dTHX>, and
their variants.

When Perl is built without options that set PERL_IMPLICIT_CONTEXT, there is no
first argument containing the interpreter's context.  The trailing underscore
in the pTHX_ macro indicates that the macro expansion needs a comma
after the context argument because other arguments follow it.  If
PERL_IMPLICIT_CONTEXT is not defined, pTHX_ will be ignored, and the
subroutine is not prototyped to take the extra argument.  The form of the
macro without the trailing underscore is used when there are no additional
explicit arguments.

When a core function calls another, it must pass the context.  This
is normally hidden via macros.  Consider C<sv_setiv>.  It expands into
something like this:

    #ifdef PERL_IMPLICIT_CONTEXT
      #define sv_setiv(a,b)      Perl_sv_setiv(aTHX_ a, b)
      /* can't do this for vararg functions, see below */
    #else
      #define sv_setiv           Perl_sv_setiv
    #endif

This works well, and means that XS authors can gleefully write:

    sv_setiv(foo, bar);

and still have it work under all the modes Perl could have been
compiled with.

This doesn't work so cleanly for varargs functions, though, as macros
imply that the number of arguments is known in advance.  Instead we
either need to spell them out fully, passing C<aTHX_> as the first
argument (the Perl core tends to do this with functions like
Perl_warner), or use a context-free version.

The context-free version of Perl_warner is called
Perl_warner_nocontext, and does not take the extra argument.  Instead
it does dTHX; to get the context from thread-local storage.  We
C<#define warner Perl_warner_nocontext> so that extensions get source
compatibility at the expense of performance.  (Passing an arg is
cheaper than grabbing it from thread-local storage.)

You can ignore [pad]THXx when browsing the Perl headers/sources.
Those are strictly for use within the core.  Extensions and embedders
need only be aware of [pad]THX.

=head2 So what happened to dTHR?

C<dTHR> was introduced in perl 5.005 to support the older thread model.
The older thread model now uses the C<THX> mechanism to pass context
pointers around, so C<dTHR> is not useful any more.  Perl 5.6.0 and
later still have it for backward source compatibility, but it is defined
to be a no-op.

=head2 How do I use all this in extensions?

When Perl is built with PERL_IMPLICIT_CONTEXT, extensions that call
any functions in the Perl API will need to pass the initial context
argument somehow.  The kicker is that you will need to write it in
such a way that the extension still compiles when Perl hasn't been
built with PERL_IMPLICIT_CONTEXT enabled.

There are three ways to do this.  First, the easy but inefficient way,
which is also the default, in order to maintain source compatibility
with extensions: whenever F<XSUB.h> is #included, it redefines the aTHX
and aTHX_ macros to call a function that will return the context.
Thus, something like:

        sv_setiv(sv, num);

in your extension will translate to this when PERL_IMPLICIT_CONTEXT is
in effect:

        Perl_sv_setiv(Perl_get_context(), sv, num);

or to this otherwise:

        Perl_sv_setiv(sv, num);

You don't have to do anything new in your extension to get this; since
the Perl library provides Perl_get_context(), it will all just
work.

The second, more efficient way is to use the following template for
your Foo.xs:

        #define PERL_NO_GET_CONTEXT     /* we want efficiency */
        #include "EXTERN.h"
        #include "perl.h"
        #include "XSUB.h"

        STATIC void my_private_function(int arg1, int arg2);

        STATIC void
        my_private_function(int arg1, int arg2)
        {
            dTHX;       /* fetch context */
            ... call many Perl API functions ...
        }

        [... etc ...]

        MODULE = Foo            PACKAGE = Foo

        /* typical XSUB */

        void
        my_xsub(arg)
                int arg
            CODE:
                my_private_function(arg, 10);

Note that the only two changes from the normal way of writing an
extension is the addition of a C<#define PERL_NO_GET_CONTEXT> before
including the Perl headers, followed by a C<dTHX;> declaration at
the start of every function that will call the Perl API.  (You'll
know which functions need this, because the C compiler will complain
that there's an undeclared identifier in those functions.)  No changes
are needed for the XSUBs themselves, because the XS() macro is
correctly defined to pass in the implicit context if needed.

The third, even more efficient way is to ape how it is done within
the Perl guts:


        #define PERL_NO_GET_CONTEXT     /* we want efficiency */
        #include "EXTERN.h"
        #include "perl.h"
        #include "XSUB.h"

        /* pTHX_ only needed for functions that call Perl API */
        STATIC void my_private_function(pTHX_ int arg1, int arg2);

        STATIC void
        my_private_function(pTHX_ int arg1, int arg2)
        {
            /* dTHX; not needed here, because THX is an argument */
            ... call Perl API functions ...
        }

        [... etc ...]

        MODULE = Foo            PACKAGE = Foo

        /* typical XSUB */

        void
        my_xsub(arg)
                int arg
            CODE:
                my_private_function(aTHX_ arg, 10);

This implementation never has to fetch the context using a function
call, since it is always passed as an extra argument.  Depending on
your needs for simplicity or efficiency, you may mix the previous
two approaches freely.

Never add a comma after C<pTHX> yourself--always use the form of the
macro with the underscore for functions that take explicit arguments,
or the form without the argument for functions with no explicit arguments.

If one is compiling Perl with the C<-DPERL_GLOBAL_STRUCT> the C<dVAR>
definition is needed if the Perl global variables (see F<perlvars.h>
or F<globvar.sym>) are accessed in the function and C<dTHX> is not
used (the C<dTHX> includes the C<dVAR> if necessary).  One notices
the need for C<dVAR> only with the said compile-time define, because
otherwise the Perl global variables are visible as-is.

=head2 Should I do anything special if I call perl from multiple threads?

If you create interpreters in one thread and then proceed to call them in
another, you need to make sure perl's own Thread Local Storage (TLS) slot is
initialized correctly in each of those threads.

The C<perl_alloc> and C<perl_clone> API functions will automatically set
the TLS slot to the interpreter they created, so that there is no need to do
anything special if the interpreter is always accessed in the same thread that
created it, and that thread did not create or call any other interpreters
afterwards.  If that is not the case, you have to set the TLS slot of the
thread before calling any functions in the Perl API on that particular
interpreter.  This is done by calling the C<PERL_SET_CONTEXT> macro in that
thread as the first thing you do:

	/* do this before doing anything else with some_perl */
	PERL_SET_CONTEXT(some_perl);

	... other Perl API calls on some_perl go here ...

=head2 Future Plans and PERL_IMPLICIT_SYS

Just as PERL_IMPLICIT_CONTEXT provides a way to bundle up everything
that the interpreter knows about itself and pass it around, so too are
there plans to allow the interpreter to bundle up everything it knows
about the environment it's running on.  This is enabled with the
PERL_IMPLICIT_SYS macro.  Currently it only works with USE_ITHREADS on
Windows.

This allows the ability to provide an extra pointer (called the "host"
environment) for all the system calls.  This makes it possible for
all the system stuff to maintain their own state, broken down into
seven C structures.  These are thin wrappers around the usual system
calls (see F<win32/perllib.c>) for the default perl executable, but for a
more ambitious host (like the one that would do fork() emulation) all
the extra work needed to pretend that different interpreters are
actually different "processes", would be done here.

The Perl engine/interpreter and the host are orthogonal entities.
There could be one or more interpreters in a process, and one or
more "hosts", with free association between them.

=head1 Internal Functions

All of Perl's internal functions which will be exposed to the outside
world are prefixed by C<Perl_> so that they will not conflict with XS
functions or functions used in a program in which Perl is embedded.
Similarly, all global variables begin with C<PL_>. (By convention,
static functions start with C<S_>.)

Inside the Perl core (C<PERL_CORE> defined), you can get at the functions
either with or without the C<Perl_> prefix, thanks to a bunch of defines
that live in F<embed.h>. Note that extension code should I<not> set
C<PERL_CORE>; this exposes the full perl internals, and is likely to cause
breakage of the XS in each new perl release.

The file F<embed.h> is generated automatically from
F<embed.pl> and F<embed.fnc>. F<embed.pl> also creates the prototyping
header files for the internal functions, generates the documentation
and a lot of other bits and pieces. It's important that when you add
a new function to the core or change an existing one, you change the
data in the table in F<embed.fnc> as well. Here's a sample entry from
that table:

    Apd |SV**   |av_fetch   |AV* ar|I32 key|I32 lval

The second column is the return type, the third column the name. Columns
after that are the arguments. The first column is a set of flags:

=over 3

=item A

This function is a part of the public API. All such functions should also
have 'd', very few do not.

=item p

This function has a C<Perl_> prefix; i.e. it is defined as
C<Perl_av_fetch>.

=item d

This function has documentation using the C<apidoc> feature which we'll
look at in a second.  Some functions have 'd' but not 'A'; docs are good.

=back

Other available flags are:

=over 3

=item s

This is a static function and is defined as C<STATIC S_whatever>, and
usually called within the sources as C<whatever(...)>.

=item n

This does not need an interpreter context, so the definition has no
C<pTHX>, and it follows that callers don't use C<aTHX>.  (See
L</Background and PERL_IMPLICIT_CONTEXT>.)

=item r

This function never returns; C<croak>, C<exit> and friends.

=item f

This function takes a variable number of arguments, C<printf> style.
The argument list should end with C<...>, like this:

    Afprd   |void   |croak          |const char* pat|...

=item M

This function is part of the experimental development API, and may change
or disappear without notice.

=item o

This function should not have a compatibility macro to define, say,
C<Perl_parse> to C<parse>. It must be called as C<Perl_parse>.

=item x

This function isn't exported out of the Perl core.

=item m

This is implemented as a macro.

=item X

This function is explicitly exported.

=item E

This function is visible to extensions included in the Perl core.

=item b

Binary backward compatibility; this function is a macro but also has
a C<Perl_> implementation (which is exported).

=item others

See the comments at the top of C<embed.fnc> for others.

=back

If you edit F<embed.pl> or F<embed.fnc>, you will need to run
C<make regen_headers> to force a rebuild of F<embed.h> and other
auto-generated files.

=head2 Formatted Printing of IVs, UVs, and NVs

If you are printing IVs, UVs, or NVS instead of the stdio(3) style
formatting codes like C<%d>, C<%ld>, C<%f>, you should use the
following macros for portability

        IVdf            IV in decimal
        UVuf            UV in decimal
        UVof            UV in octal
        UVxf            UV in hexadecimal
        NVef            NV %e-like
        NVff            NV %f-like
        NVgf            NV %g-like

These will take care of 64-bit integers and long doubles.
For example:

        printf("IV is %"IVdf"\n", iv);

The IVdf will expand to whatever is the correct format for the IVs.

If you are printing addresses of pointers, use UVxf combined
with PTR2UV(), do not use %lx or %p.

=head2 Pointer-To-Integer and Integer-To-Pointer

Because pointer size does not necessarily equal integer size,
use the follow macros to do it right.

        PTR2UV(pointer)
        PTR2IV(pointer)
        PTR2NV(pointer)
        INT2PTR(pointertotype, integer)

For example:

        IV  iv = ...;
        SV *sv = INT2PTR(SV*, iv);

and

        AV *av = ...;
        UV  uv = PTR2UV(av);

=head2 Exception Handling

There are a couple of macros to do very basic exception handling in XS
modules. You have to define C<NO_XSLOCKS> before including F<XSUB.h> to
be able to use these macros:

        #define NO_XSLOCKS
        #include "XSUB.h"

You can use these macros if you call code that may croak, but you need
to do some cleanup before giving control back to Perl. For example:

        dXCPT;    /* set up necessary variables */

        XCPT_TRY_START {
          code_that_may_croak();
        } XCPT_TRY_END

        XCPT_CATCH
        {
          /* do cleanup here */
          XCPT_RETHROW;
        }

Note that you always have to rethrow an exception that has been
caught. Using these macros, it is not possible to just catch the
exception and ignore it. If you have to ignore the exception, you
have to use the C<call_*> function.

The advantage of using the above macros is that you don't have
to setup an extra function for C<call_*>, and that using these
macros is faster than using C<call_*>.

=head2 Source Documentation

There's an effort going on to document the internal functions and
automatically produce reference manuals from them - L<perlapi> is one
such manual which details all the functions which are available to XS
writers. L<perlintern> is the autogenerated manual for the functions
which are not part of the API and are supposedly for internal use only.

Source documentation is created by putting POD comments into the C
source, like this:

 /*
 =for apidoc sv_setiv

 Copies an integer into the given SV.  Does not handle 'set' magic.  See
 C<sv_setiv_mg>.

 =cut
 */

Please try and supply some documentation if you add functions to the
Perl core.

=head2 Backwards compatibility

The Perl API changes over time. New functions are added or the interfaces
of existing functions are changed. The C<Devel::PPPort> module tries to
provide compatibility code for some of these changes, so XS writers don't
have to code it themselves when supporting multiple versions of Perl.

C<Devel::PPPort> generates a C header file F<ppport.h> that can also
be run as a Perl script. To generate F<ppport.h>, run:

    perl -MDevel::PPPort -eDevel::PPPort::WriteFile

Besides checking existing XS code, the script can also be used to retrieve
compatibility information for various API calls using the C<--api-info>
command line switch. For example:

  % perl ppport.h --api-info=sv_magicext

For details, see C<perldoc ppport.h>.

=head1 Unicode Support

Perl 5.6.0 introduced Unicode support. It's important for porters and XS
writers to understand this support and make sure that the code they
write does not corrupt Unicode data.

=head2 What B<is> Unicode, anyway?

In the olden, less enlightened times, we all used to use ASCII. Most of
us did, anyway. The big problem with ASCII is that it's American. Well,
no, that's not actually the problem; the problem is that it's not
particularly useful for people who don't use the Roman alphabet. What
used to happen was that particular languages would stick their own
alphabet in the upper range of the sequence, between 128 and 255. Of
course, we then ended up with plenty of variants that weren't quite
ASCII, and the whole point of it being a standard was lost.

Worse still, if you've got a language like Chinese or
Japanese that has hundreds or thousands of characters, then you really
can't fit them into a mere 256, so they had to forget about ASCII
altogether, and build their own systems using pairs of numbers to refer
to one character.

To fix this, some people formed Unicode, Inc. and
produced a new character set containing all the characters you can
possibly think of and more. There are several ways of representing these
characters, and the one Perl uses is called UTF-8. UTF-8 uses
a variable number of bytes to represent a character. You can learn more
about Unicode and Perl's Unicode model in L<perlunicode>.

=head2 How can I recognise a UTF-8 string?

You can't. This is because UTF-8 data is stored in bytes just like
non-UTF-8 data. The Unicode character 200, (C<0xC8> for you hex types)
capital E with a grave accent, is represented by the two bytes
C<v196.172>. Unfortunately, the non-Unicode string C<chr(196).chr(172)>
has that byte sequence as well. So you can't tell just by looking - this
is what makes Unicode input an interesting problem.

In general, you either have to know what you're dealing with, or you
have to guess.  The API function C<is_utf8_string> can help; it'll tell
you if a string contains only valid UTF-8 characters. However, it can't
do the work for you. On a character-by-character basis,
C<is_utf8_char_buf>
will tell you whether the current character in a string is valid UTF-8. 

=head2 How does UTF-8 represent Unicode characters?

As mentioned above, UTF-8 uses a variable number of bytes to store a
character. Characters with values 0...127 are stored in one byte, just
like good ol' ASCII. Character 128 is stored as C<v194.128>; this
continues up to character 191, which is C<v194.191>. Now we've run out of
bits (191 is binary C<10111111>) so we move on; 192 is C<v195.128>. And
so it goes on, moving to three bytes at character 2048.

Assuming you know you're dealing with a UTF-8 string, you can find out
how long the first character in it is with the C<UTF8SKIP> macro:

    char *utf = "\305\233\340\240\201";
    I32 len;

    len = UTF8SKIP(utf); /* len is 2 here */
    utf += len;
    len = UTF8SKIP(utf); /* len is 3 here */

Another way to skip over characters in a UTF-8 string is to use
C<utf8_hop>, which takes a string and a number of characters to skip
over. You're on your own about bounds checking, though, so don't use it
lightly.

All bytes in a multi-byte UTF-8 character will have the high bit set,
so you can test if you need to do something special with this
character like this (the UTF8_IS_INVARIANT() is a macro that tests
whether the byte can be encoded as a single byte even in UTF-8):

    U8 *utf;
    U8 *utf_end; /* 1 beyond buffer pointed to by utf */
    UV uv;	/* Note: a UV, not a U8, not a char */
    STRLEN len; /* length of character in bytes */

    if (!UTF8_IS_INVARIANT(*utf))
        /* Must treat this as UTF-8 */
        uv = utf8_to_uvchr_buf(utf, utf_end, &len);
    else
        /* OK to treat this character as a byte */
        uv = *utf;

You can also see in that example that we use C<utf8_to_uvchr_buf> to get the
value of the character; the inverse function C<uvchr_to_utf8> is available
for putting a UV into UTF-8:

    if (!UTF8_IS_INVARIANT(uv))
        /* Must treat this as UTF8 */
        utf8 = uvchr_to_utf8(utf8, uv);
    else
        /* OK to treat this character as a byte */
        *utf8++ = uv;

You B<must> convert characters to UVs using the above functions if
you're ever in a situation where you have to match UTF-8 and non-UTF-8
characters. You may not skip over UTF-8 characters in this case. If you
do this, you'll lose the ability to match hi-bit non-UTF-8 characters;
for instance, if your UTF-8 string contains C<v196.172>, and you skip
that character, you can never match a C<chr(200)> in a non-UTF-8 string.
So don't do that!

=head2 How does Perl store UTF-8 strings?

Currently, Perl deals with Unicode strings and non-Unicode strings
slightly differently. A flag in the SV, C<SVf_UTF8>, indicates that the
string is internally encoded as UTF-8. Without it, the byte value is the
codepoint number and vice versa (in other words, the string is encoded
as iso-8859-1, but C<use feature 'unicode_strings'> is needed to get iso-8859-1
semantics). You can check and manipulate this flag with the
following macros:

    SvUTF8(sv)
    SvUTF8_on(sv)
    SvUTF8_off(sv)

This flag has an important effect on Perl's treatment of the string: if
Unicode data is not properly distinguished, regular expressions,
C<length>, C<substr> and other string handling operations will have
undesirable results.

The problem comes when you have, for instance, a string that isn't
flagged as UTF-8, and contains a byte sequence that could be UTF-8 -
especially when combining non-UTF-8 and UTF-8 strings.

Never forget that the C<SVf_UTF8> flag is separate to the PV value; you
need be sure you don't accidentally knock it off while you're
manipulating SVs. More specifically, you cannot expect to do this:

    SV *sv;
    SV *nsv;
    STRLEN len;
    char *p;

    p = SvPV(sv, len);
    frobnicate(p);
    nsv = newSVpvn(p, len);

The C<char*> string does not tell you the whole story, and you can't
copy or reconstruct an SV just by copying the string value. Check if the
old SV has the UTF8 flag set, and act accordingly:

    p = SvPV(sv, len);
    frobnicate(p);
    nsv = newSVpvn(p, len);
    if (SvUTF8(sv))
        SvUTF8_on(nsv);

In fact, your C<frobnicate> function should be made aware of whether or
not it's dealing with UTF-8 data, so that it can handle the string
appropriately.

Since just passing an SV to an XS function and copying the data of
the SV is not enough to copy the UTF8 flags, even less right is just
passing a C<char *> to an XS function.

=head2 How do I convert a string to UTF-8?

If you're mixing UTF-8 and non-UTF-8 strings, it is necessary to upgrade
one of the strings to UTF-8. If you've got an SV, the easiest way to do
this is:

    sv_utf8_upgrade(sv);

However, you must not do this, for example:

    if (!SvUTF8(left))
        sv_utf8_upgrade(left);

If you do this in a binary operator, you will actually change one of the
strings that came into the operator, and, while it shouldn't be noticeable
by the end user, it can cause problems in deficient code.

Instead, C<bytes_to_utf8> will give you a UTF-8-encoded B<copy> of its
string argument. This is useful for having the data available for
comparisons and so on, without harming the original SV. There's also
C<utf8_to_bytes> to go the other way, but naturally, this will fail if
the string contains any characters above 255 that can't be represented
in a single byte.

=head2 Is there anything else I need to know?

Not really. Just remember these things:

=over 3

=item *

There's no way to tell if a string is UTF-8 or not. You can tell if an SV
is UTF-8 by looking at its C<SvUTF8> flag. Don't forget to set the flag if
something should be UTF-8. Treat the flag as part of the PV, even though
it's not - if you pass on the PV to somewhere, pass on the flag too.

=item *

If a string is UTF-8, B<always> use C<utf8_to_uvchr_buf> to get at the value,
unless C<UTF8_IS_INVARIANT(*s)> in which case you can use C<*s>.

=item *

When writing a character C<uv> to a UTF-8 string, B<always> use
C<uvchr_to_utf8>, unless C<UTF8_IS_INVARIANT(uv))> in which case
you can use C<*s = uv>.

=item *

Mixing UTF-8 and non-UTF-8 strings is tricky. Use C<bytes_to_utf8> to get
a new string which is UTF-8 encoded, and then combine them.

=back

=head1 Custom Operators

Custom operator support is an experimental feature that allows you to
define your own ops. This is primarily to allow the building of
interpreters for other languages in the Perl core, but it also allows
optimizations through the creation of "macro-ops" (ops which perform the
functions of multiple ops which are usually executed together, such as
C<gvsv, gvsv, add>.)

This feature is implemented as a new op type, C<OP_CUSTOM>. The Perl
core does not "know" anything special about this op type, and so it will
not be involved in any optimizations. This also means that you can
define your custom ops to be any op structure - unary, binary, list and
so on - you like.

It's important to know what custom operators won't do for you. They
won't let you add new syntax to Perl, directly. They won't even let you
add new keywords, directly. In fact, they won't change the way Perl
compiles a program at all. You have to do those changes yourself, after
Perl has compiled the program. You do this either by manipulating the op
tree using a C<CHECK> block and the C<B::Generate> module, or by adding
a custom peephole optimizer with the C<optimize> module.

When you do this, you replace ordinary Perl ops with custom ops by
creating ops with the type C<OP_CUSTOM> and the C<op_ppaddr> of your own
PP function. This should be defined in XS code, and should look like
the PP ops in C<pp_*.c>. You are responsible for ensuring that your op
takes the appropriate number of values from the stack, and you are
responsible for adding stack marks if necessary.

You should also "register" your op with the Perl interpreter so that it
can produce sensible error and warning messages. Since it is possible to
have multiple custom ops within the one "logical" op type C<OP_CUSTOM>,
Perl uses the value of C<< o->op_ppaddr >> to determine which custom op
it is dealing with. You should create an C<XOP> structure for each
ppaddr you use, set the properties of the custom op with
C<XopENTRY_set>, and register the structure against the ppaddr using
C<Perl_custom_op_register>. A trivial example might look like:

    static XOP my_xop;
    static OP *my_pp(pTHX);

    BOOT:
        XopENTRY_set(&my_xop, xop_name, "myxop");
        XopENTRY_set(&my_xop, xop_desc, "Useless custom op");
        Perl_custom_op_register(aTHX_ my_pp, &my_xop);

The available fields in the structure are:

=over 4

=item xop_name

A short name for your op. This will be included in some error messages,
and will also be returned as C<< $op->name >> by the L<B|B> module, so
it will appear in the output of module like L<B::Concise|B::Concise>.

=item xop_desc

A short description of the function of the op.

=item xop_class

Which of the various C<*OP> structures this op uses. This should be one of
the C<OA_*> constants from F<op.h>, namely

=over 4

=item OA_BASEOP

=item OA_UNOP

=item OA_BINOP

=item OA_LOGOP

=item OA_LISTOP

=item OA_PMOP

=item OA_SVOP

=item OA_PADOP

=item OA_PVOP_OR_SVOP

This should be interpreted as 'C<PVOP>' only. The C<_OR_SVOP> is because
the only core C<PVOP>, C<OP_TRANS>, can sometimes be a C<SVOP> instead.

=item OA_LOOP

=item OA_COP

=back

The other C<OA_*> constants should not be used.

=item xop_peep

This member is of type C<Perl_cpeep_t>, which expands to C<void
(*Perl_cpeep_t)(aTHX_ OP *o, OP *oldop)>. If it is set, this function
will be called from C<Perl_rpeep> when ops of this type are encountered
by the peephole optimizer. I<o> is the OP that needs optimizing;
I<oldop> is the previous OP optimized, whose C<op_next> points to I<o>.

=back

C<B::Generate> directly supports the creation of custom ops by name.

=head1 AUTHORS

Until May 1997, this document was maintained by Jeff Okamoto
E<lt>okamoto@corp.hp.comE<gt>.  It is now maintained as part of Perl
itself by the Perl 5 Porters E<lt>perl5-porters@perl.orgE<gt>.

With lots of help and suggestions from Dean Roehrich, Malcolm Beattie,
Andreas Koenig, Paul Hudson, Ilya Zakharevich, Paul Marquess, Neil
Bowers, Matthew Green, Tim Bunce, Spider Boardman, Ulrich Pfeifer,
Stephen McCamant, and Gurusamy Sarathy.

=head1 SEE ALSO

L<perlapi>, L<perlintern>, L<perlxs>, L<perlembed>

=head1 ПЕРЕВОДЧИКИ
  
=over
  
=item * Андрей Асякин C<< <asan999 at gmail.com> >>
  
=item * Николай Мишин C<< <mi at ya.ru> >>
 
=back
