
=encoding UTF-8

=head1 NAME

X<регулярное выражение> X<регекс> X<регексп>

perlre - Регулярные выражения Perl

=head1 ОПИСАНИЕ

Эта страница описывает синтаксис регулярных выражений в Perl.

Если вы раньше не использовали регулярные выражения, то есть быстрое введение в L<perlrequick> и более длинное в L<perlretut>.

О том, как регулярные выражения используются в поиске по шаблону,  а также различные примеры см. обсуждение C<m//>, C<s///>, C<qr//> и C<??> в L<perlop/"Regexp операторы заключения в кавычки">.


=head2 Модификаторы

Операторы поиска по шаблону имеют разные модификаторы.  Модификаторы, которые относятся к интерпретации внутри регулярных выражений  перечислены ниже.  Модификаторы, которые изменяют путь регулярного выражения, использующегося в Perl, детализированы в  L<perlop/"Regexp операторы заключения в кавычки"> и
L<perlop/"Внутренние детали парсинга конструкций в кавычках">.

=over 4

=item m
X</m> X<регекс, многострочный> X<регексп, многострочный> X<регулярное выражение, многострочный>

Представляет строку поиска, как многострочную. Разрешает метасимволам ^ и $ привязываться к промежуточным символам \n, имеющимся в тексте.

=item s
X</s> X<regex, single-line> X<regexp, single-line>
X<regular expression, single-line>

Метасимволу "точка" разрешено соответствовать \n.(s - single line)

Используя вместе C</ms> позволяет "." соответствовать 
любому символу включая новую строку а символы "^" и "$"
становятся началом и концом всего буфера.

=item i
X</i> X<regex, case-insensitive> X<regexp, case-insensitive>
X<regular expression, case-insensitive>

Игнорирует регистр символов при сопоставлении с образцом.

Если правила поиска локали включены, текущая карта символов берется из текущей локали для символов с кодом менее 255 и используются юникодные правила для больших кодовых точек.  Однако поиск, который будет пересекать правила Unicode / не Unicode  на границе (Ords 255/256) не удастся.  См.
L<perllocale>.

Есть целый ряд символов Юникода, которым соответствуют несколько символов под C</i>  Например, C<LATIN SMALL LIGATURE FI> должен найти последовательность C</fi>  Perl в настоящее время не в состоянии сделать это, когда   несколько символов в шаблоне и они разделены между группировками, или когда один или больше квантификаторов.  Таким образом
use charnames ':full'; #примечание переводчика

 "\N{LATIN SMALL LIGATURE FI}" =~ /fi/i;          # найдет
 "\N{LATIN SMALL LIGATURE FI}" =~ /[fi][fi]/i;    # Не найдет!
 "\N{LATIN SMALL LIGATURE FI}" =~ /fi*/i;         # Не найдет!

 # Ниже не будет соответствия, и не ясно, что было бы в $1 и $2
 # будьте честны, если это произойдет
 "\N{LATIN SMALL LIGATURE FI}" =~ /(f)(i)/i;      # Не найдет!

Perl не находит несколько символов в скобках (образующих класс), если только знак, который отображается на них прямо упоминается, и он не находит вообще, если класс символов инвертирован, что в противном случае могло бы быть очень запутанно.  См.
L<perlrecharclass/Bracketed Character Classes>, and
L<perlrecharclass/Negation>.

=item x
X</x>

Увеличивает читаемость вашего шаблона для поиска, разрешаются пробелы и комментарии.
Подробности в L</"/x">

=item p
X</p> X<regex, preserve> X<regexp, preserve>

Сохраненные части строки, такие как ${^PREMATCH}, ${^MATCH}, и
${^POSTMATCH}  доступны для использования после поиска по шаблону.

=item g и c
X</g> X</c>

Глобальный поиск совпадений, и сохранение текущей позиции после неудачного поиска.
В отличие от i, m, s и x,эти два флага влияют затрагиваем способ, которым regex используется, а не сам regex. См.
L<perlretut/"Using regular expressions in Perl"> (Использование регулярных выражений Perl)для получения большей информации
о модификаторах g и c.

=item a, d, l и u
X</a> X</d> X</l> X</u>

Эти модификаторы, все новые в 5.14, влияют при какая семантике кодировки (Unicode, и т.д.) используются, как описано ниже в L </модификаторы Кодировки>.}

=back

Модификаторы регулярных выражений  обычно описываются в документации, например,как " C</x> модификатор" несмотря на косую черту, разделителем может быть не только слэш.  Модификаторы C</imsxadlup>
могут также быть включены в пределах самого регулярного выражения, используя конструкцию C<(?...)> , см.  L</Extended Patterns>  (L</Расширенные Образцы>) ниже.

=head3 /x

C</x> говорит регулярному анализатору выражения игнорировать большую часть пробелов, перед которыми не стоит обратный слэш и не входящих в класс символов.  Вы можете использовать это, чтобы разбить ваше регулярное выражение на части, чтобы сделать его более читаемым.  Символ  C<#> также рассматривается как метасимвол, являющимся комментарием, как в обычном коде Perl.  Это также означает, что если вы хотите реальный пробел или символ C<#> в шаблоне поиска (вне класса характера, где они не затронуты C</x>), тогда вы должны будете или эскейпить их (используя наклонную черту влево или C<\Q...\E>) или кодировать их используя восьмеричный, шестнадцатеричный или  C<\N{}> код.  Взятые вместе, эти фичи (features) имеют большое значение для создания более читаемых регулярных выражений в Perl.  Обратите внимание, что вы должны быть осторожны, чтобы не включать разделитель шаблона в комментарий --perl не имеет никакого способа узнать, что вы не намеревались закрыть шаблон раньше.  См. удаление комментариев  в C коде в L<perlop>.  Также отметим, что все внутри C<\Q...\E> остается не зависимым от C</x>.  И заметьте, что C</x> не влияет на интерпретацию пространства в пределах одной многосимвольной конструкции.  Например, в C<\x{...}>,  независимо от модификатора C</x>,  не может быть пробелов.  То же самое для  L<quantifier|/Quantifiers> таких как C<{3}> или
C<{5,}>.  Аналогично, C<(?:...)> не может иметь пробелов между C<(>,
C<?>, и C<:>.  В пределах любых разделителей для такой конструкции, позволенные пробелы не имеют силы из-за C</x> и зависят от конструкции.  Например, C<\x{...}>  не должно быть пробелов, потому что шестнадцатеричные числа не имеют в себе пробелов.  Но, у свойств Unicode (Unicode properties) могут быть пробелы, таким образом, в C<\p{...}>  могут быть пробелы, которые следуют за правилами Unicode, для которых см. L<perluniprops/Properties accessible through \p{} and \P{}> (L <perluniprops/Свойства, доступные через \p{} и  \P{}>)
X</x>

=head3 Модификаторы Кодировки

C</d>, C</u>, C</a>, и C</l>, доступные, начиная с 5.14, называют модификаторами кодировки; они затрагивают семантику кодировки, используемую для регулярного выражения.

Модификаторы C</d>, C</u>, и  C</l> вряд ли будут иметь большое применения
вами, и таким образом, вы не должны о них очень волноваться. Они существуют для
внутреннего использования Perl, так, чтобы сложные структуры данных регулярных выражений
могли быть автоматически преобразованы в последовательную форму и позже точно воссозданы,
включая все их нюансы. Но, так как Perl не может хранить все в тайне, и
могут быть редкие случаи, где они полезны, они задокументированы здесь.

Модификатор C</a>, с другой стороны, может быть полезным. Его цель заключается в том, что он
позволяет коду работать главным образом на данных ASCII, чтобы не иметь проблем
с Unicode.

Кратко, C</l> задает кодировку, которая будет работать в любой
<L>ocale во время выполнения поиска по шаблону.

C</u> задает кодировку B<Ю>никод.

C</a> также устанавливает набор символов для Юникода, но добавляет несколько
ограничений B<A>SCII-безопасного поиска.

C</d> является старым, проблематичным, перед-5.14 B<Н>бором по умолчанию символов
поведение. Используется только для этого старого поведения.

В любой момент времени только один из этих модификаторов действует. Их
существование позволяет Perl сохранить первоначально скомпилированное поведение
регулярного выражения, независимо от действий правил, когда оно
действительно выполняется. И, если он интерполируется в больших регекс,
оригинал в правила продолжают применяться к нему и только к нему.

C</l> и C</u> модификаторы автоматически выбираются для
регулярных выражений, скомпилированных в рамках различных прагм,
и мы рекомендуем, в общем, чтобы вы использовали эти прагмы вместо
явного указания этих модификаторов. Для одной вещи, модификаторы
затрагивают только шаблоны поиска и не распространяются даже на сделанную замену
, тогда как использование прагма-директивы даёт постоянные результаты для всех
соответствующие операций в пределах их области. Например,

 s/foo/\Ubar/il

найдет "foo", используя локальные правила языкового стандарта для сопоставления без учета регистра,
но C</l> не влияет, когда работает C <\U>. Скорее всего вы
хотите, чтобы оба из них использовали локальные правила. Для этого нужно компилировать
регулярное выражение в рамках C<use locale>. Это 
неявно добавляет C</l> и применяет правила языка к C <\U>. 
Урок заключается в том, чтобы использовать  C<use locale> и не использовать явно C</l>.

Аналогичным образом было бы лучше использовать  C<use feature 'unicode_strings'>
вместо

 s/foo/\Lbar/iu

чтобы получить правила Юникода, как в бывшем C<\L> (но не обязательно
последнем) будет также использовать правила Юникода.

Более подробно о каждом из модификаторов смотри далее. Скорее всего вам не
нужно знать эти детали для C</l>, C</u> и С</d> и можете пропустить вперед
 L<E<sol>a|/E<sol>a (и E<sol>aa)>.

=head4 /l

используется для правил текущей локали  (см. L<perllocale>) когда шаблон найден. 
Например C<\w> будет совпадать с символами "слова" текущей локали 
и C<"/i"> регистронезависимый поиск будет искать согласно
текущим правилам регистронезависимого сравнения. Будет использоваться одна локаль
во время поиска по шаблону. Это может быть не
то же самое, как во время локали времени компиляции и поиск может отличаться один от другого
 если еще есть промежуточный вызов из
L<setlocale() function|perllocale/The setlocale function>.

Perl поддерживает только однобайтовые локали. Это означает, что код символа, который 
выше 255, рассматриваются как Юникод независимо от того, какая локаль действует.
Согласно правилам Юникода есть несколько локалей без учета регистра, которые пересекают границу
255/256 . Они запрещены при C</l>. Например,
0xFF (на ASCII платформах) не соответствует символу 0x178,C<LATIN CAPITAL LETTER Y WITH DIAERESIS>, в подшаблоне
, потому что 0xFF не может быть 
C<LATIN SMALL LETTER Y WITH DIAERESIS> в текущей локали, и Perl
не имеет возможности узнать даже существует ли этот символ в этой локали.

Этот модификатор можно определить, используя C<use locale>, но посмотрите
 L</Какой набор символьных модификаторов действует?>.
X</l>

=head4 /u

означает использования правил Unicode во время поиска по шаблону. На платформах ASCII
это означает, что символы с кодом от 128 до 255 такие, как 
Latin-1 (ISO-8859-1) значения (которые такие же, как в Юникоде).
(Иначе Perl считает, что их значение будет неопределенным). Таким образом,
под этот модификатором платформа ASCII фактически становится Юникодной
платформой; и следовательно, к примеру, C<\w> будет соответствовать любому из более чем
100_000 буквенных символов в Юникоде.

В отличие от большинства локалей, которые являются специфическими для пары язык-страна,
Юникод классифицирует все символы, как символ для письма, которые используются I<где угодно>
в мире, как C<\w>. Например, ваша локаль может не считать C<LATIN SMALL
LETTER ETH> как строковый символ (пока вы не будете говорить на исландском), а Юникод принимает этот символ за строчный. Аналогичным образом все символы, десятичные цифры
 везде в мире будут соответствовать C<\d>; это сотни, а не 10-ки
возможных совпадений. И некоторые из этих цифр выглядят, как некоторые из 10
ASCII цифр, но означают другое число, поэтому человек легко может думать, что это
совсем другое число, чем на самом деле. Например,
C<BENGALI DIGIT FOUR> (U+09EA)  выглядит очень похоже на
C<ASCII DIGIT EIGHT> (U+0038). И C<\d+> может найти символы , которые могут соответствовать символам цифр,
 которые представляют собой смесь из различных систем письма, созданных из соображений безопасности. 
 L<Unicode::UCD/num()> может использоваться для сортировки. 
 А модификатор C</a> может использоваться для принудительного поиска шаблоном C<\d>  
только ASCII цифр от 0 до 9.
 
Кроме того под этим модификатором, регистронезависимый поиск символов работает на полном
наборе Юникодных символов. C<KELVIN SIGN>, например совпадает с буквами "k" и
"K"; и  C<LATIN SMALL LIGATURE FF> соответствует последовательности "ff", которая,
если вы не подготовлены, может выглядеть, как шестнадцатеричная константа,
что представляет еще одну потенциальную проблему безопасности. См.
L<http://unicode.org/reports/tr36> для подробного обсуждения 
вопросов безопасности в Юникоде.

Этот модификатор может определяться по умолчанию, используя C<use feature
'unicode_strings>,  C<use locale ':not_characters'>, или
C<L<use 5.012|perlfunc/use VERSION>>>> (или выше),
но посмотрите главу L</Какой набор символьных модификаторов действует?>.
X</u>

=head4 /d

Этот модификатор означает использование собственные правила платформы "По умолчанию",
за исключением случаев, когда вместо этого есть основания для использования правил Юникода, следующим образом:

=over 4

=item 1

целевая строка кодируется в UTF-8; или

=item 2

шаблон кодируется в UTF-8; или

=item 3

шаблон явно упоминает код символа, который находится выше 255 (скажем
C<\x{100}>); или

=item 4

шаблон использует Юникодное имя (C<\N{...}>);  или

=item 5

шаблон использует Юникодное свойство (C<\p{...}>); или

=item 6

шаблон использует L</C<(?[ ])>>

=back

Другая мнемоника для этого модификатора "Зависит от", и правила, которые на самом деле
используются зависят от различных вещей, и в результате вы можете получить неожиданные
результаты. Смотрите L<perlunicode/"<Bug Юникода">.  Ошибка Unicode 
становиться довольно печальной, ведущих к еще одному (версия для печати) имени для этого
модификатора, "Dodgy" "Непредсказуемый" или "Рисковый".

Если шаблон или строки не кодируются в UTF-8, то буду найдены только символы ASCII.

Вот некоторые примеры того, как это работает на ASCII платформе:

 $str =  "\xDF";      # $str не в UTF-8 формате.
 $str =~ /^\w/;       # Не найдет, так как $str не в UTF-8 формате.
 $str .= "\x{0e0b}";  # Теперь строка $str в UTF-8 формате.
 $str =~ /^\w/;       # Найдет! $str теперь в UTF-8 формате.
 chop $str;
 $str =~ /^\w/;       # Все еще найдет! $str остается в UTF-8 формате.

Этот модификатор автоматически выбирается по умолчанию, если ни один другой не указан
, таким образом для него другое имя — "По умолчанию" ("Default").

Из-за неожиданного поведения, связанные с этим модификатором, вам
вероятно следует его использовать только, его вам нужно сохранить странные обратные совместимости.

=head4 /a (и /aa)

Этот модификатор выступает за ASCII строгость  (или ASCII-безопасность). Этот модификатор,
в отличие от других, может в два раза расширить свой эффект.

Когда он появляется один, то он применяется к последовательности  C<\d>, C<\s>, C<\w>, и
классам символов Posix для соответствия только в диапазоне ASCII.
Они, таким образом, возвращаются к версиям до 5.6 (pre-5.6), бывшим еще до значений Юникода (pre-Unicode).
Под модификатором C</a>,  C<\d>
всегда означает только цифры от C<"0"> до C<"9">; C<\s> означает пять символов
 C<[ \f\n\r\t]>, и начиная с Perl v5.18, экспериментально,
 вертикальный табулятор; C<\w> означает 63 символа
C<[A-Za-z0-9_]>; кроме того, все Posix классы такие как 
C<[[:print:]]> найдут только соответствующие символы ASCII-диапазона.

Этот модификатор является полезным для людей, которые только изредка используют Юникод,
и, которые не желают обременяться его сложностью и проблемами безопасности.

С модификатором C</a>, вы можете написать C<\d> с уверенностью, что он точно найдет только
ASCII символы, и, если вам нужно найти что-то за пределами символов ASCII, вы можете 
вместо этого использовать C<\p{Digit}> (или C<\p{Word}> для C<\w>).  
Есть аналогичные конструкции C<\p{...}> , которые могут соответствовать символам за пределами ASCII 
как для пробельных символов (см.  L<perlrecharclass/Whitespace>) , так и для классов Posix (см.
L<perlrecharclass/POSIX Character Classes>.
Таким образом этот модификатор не означает, что вы не можете использовать Unicode, 
это означает, что для поиска Юникодных символов вы должны явно использовать конструкцию (C<\p{}>, C<\P{}>),
 которая говорит о том, что это Юникод.

Как и следовало ожидать, этот модификатор вызывает, например, что C<\D> означает то же, что и
C<[^0-9]>; в самом деле все не ASCII находят
C<\D>, C<\S>, и C<\W>.  C<\b> по-прежнему соответствует границе
между C<\w> и C<\W>, используя свое определение при модификаторе C</a> (аналогично
для C<\B>).

В противном случае C</a> ведет себя как модификатор C</u> , в 
регистронезависимом поиске семантики Юникодных символов; к примеру будет "k"
найдет юникодный C<\N{KELVIN SIGN}> при поиске с модификатором C</i>  и код
символов в диапазоне Latin1, выше ASCII будет иметь правила Юникода, как они действуют
 при поиске без учета регистра.

Для запрещения поиска ASCII/не-ASCII (например, как "k" с C<\N{KELVIN SIGN}>),
поставьте "a" дважды, например C</aai> или C</aia>.  (Первой появление
 "a" ограничивает C<\d>, и так далее, а второе появление
 добавляет ограничение для C</i>.) Но, нужно заметить, что для символов вне 
 диапазона
ASCII будет использоваться правила Юникода для C</i> поиска, таким образом, модификатор,
 в действительности, не ограничивает символы только ASCII диапазоном; он просто запрещает
смешение символов ASCII и не ASCII диапазона.

Подводя итог, этот модификатор обеспечивает защиту для приложений, которые
 не хотят быть подвержены влиянию Юникода. Указав его дважды
  вы получаете дополнительную защиту.

Этот модификатор может быть указан по умолчанию с помощью C<use re '/a'>
или C<use re '/aa'>.  Если вы так сделаете, вы можете иметь возможность использовать модификатор
C</u> явно, если существует несколько регулярных выражений,
где вы хотите использовать полные правила Юникода
(но даже здесь, лучше, если бы работала функция 
 C<"unicode_strings">, наряду с
C<use re '/aa'>).  Также смотри L</Какой набор символьных модификаторов действует?>.
X</a>
X</aa>

=head4 Какой набор символьных модификаторов действует?

Какой набор символьных модификаторов действует
в любой месте регулярного выражения зависит от набора довольно сложных взаимодействий.
Они разработаны таким образом, что в целом вам не придется беспокоиться об этом, но
этот раздел даст вам кровавые подробности.
Как объясняется ниже в L</Расширенных шаблонах> это возможно явно
указав модификаторы, которые применяются только к части регулярного выражения.
Внутреннее всегда имеет приоритет над любым внешним и одно применение
для целого выражения имеет приоритет над любым из параметров по умолчанию,
описанному в оставшейся части этого раздела.

Прагма C<L<use re 'E<sol>foo'|re/"'/flags' mode">> может использоваться для установки модификаторов 
по умолчанию (включая эти) для скомпилированных регулярных выражений
в пределах своей области.  Эта прагма имеет приоритет над другими прагмами,
перечисленные ниже, что также изменяет значения по умолчанию.

Иначе, C<L<use locale|perllocale>> устанавливает модификатор по умолчанию в C</l>;
и C<L<use feature 'unicode_strings|feature>>, или
C<L<use 5.012|perlfunc/use VERSION>> (или выше) установка умолчания в
C</u> когда не в той же области, либо как C<L<use locale|perllocale>>
или C<L<use bytes|bytes>>.
(C<L<use locale ':not_characters'|perllocale/Unicode and UTF-8>> также
устанавливают умолчание в C</u>, переопределяет и простой C<use locale>.)
В отличие от механизмов, упомянутых выше, эти
операнды влияют на операции помимо поиска регулярного выражения по шаблону  и поэтому
дают более последовательные результаты с другими операторами, в том числе с использованием
C<\U>, C<\l> и т.д. в операциях замены.

Если ни один из перечисленных выше вариантов не применяется, то, для обратной совместимости
модификатор C</d> является в сущности по умолчанию. Так как это может привести к
неожиданным результатам, то лучше указать какой другой набор правил должен 
использоваться.

=head4 Модификатор поведения набора символов до Perl 5.14

До 5.14, были не было явных модификаторов, но C</l> подразумевается
для регулярных выражений, скомпилированные в пределах действия прагм  C<use locale> и C</d> 
подразумевался иначе.Однако интерполяция регексов в больших регексах
будет игнорировать оригинальную компиляцию в пользу всего, что было в действительности
во время второй компиляции. Существует ряд несоответствий (ошибок) 
с модификатором C</d> , где правила Юникода
будут неуместны и наоборот.C <\p{}> не подразумевает
правил Юникода и не делает все вхождения C<\N{}>, до 5.12.

=head2 Регулярные выражения

=head3 Метасимволы

Шаблоны, используемые в Perl эволюционировали от тех, 
которые были в Процедурах Регулярных Выражениях Версии 8 (Version 8 regex routines).
Процедуры являются производными (отдаленно) 
от свободно распространяемой повторной реализации подпрограмм версии V8 Генри Спенсера .
См. L<Версия 8 Регулярных Выражений> для подробностей.

В частности следующие метасимволы имеют значения по I<egrep>-ному стандарту:
X<метасимволы>
X<\> X<^> X<.> X<$> X<|> X<(> X<()> X<[> X<[]>


    \        Экранирование следующего метасимвола
    ^        Найдет начало строки
    .        Найдет любой символ (кроме символа новой строки)
    $        Найдет конец строки (перед символом новой строки в конце)
    |        Альтернатива
    ()       Группировка
    []       Класс символов в квадратных скобках

По умолчанию, символ "^" гарантирует, что найдется только начало строки
, а символ "$" найдет только конец (или перед символом новой строки в конце
), и Perl делает определенные оптимизации, предполагая, что набор символов содержит только одну строку.
Внутренние новые строки не будут найдены "^" или "$".  Вы можете, тем не менее пожелать
представить символы для поиска как буфер из многих строк, тогда "^" будет найдет после любого символа новой строки внутри символов для поиска (исключением является случай, когда 
символ новой строки является последним символом в строке поиска), 
и "$" найдет перед любым символом новой строки. Стоимость накладных 
расходов немного больше, если вы применяете к шаблону поиска модификатор /m.
(Старые программы делали это, устанавливая C<$*>,
но эта возможность удалена в perl 5.10.)
X<^> X<$> X</m>

Для упрощения замены в многострочном буфере, символ "." никогда не найдет
 символ новой строки, только, если вы не используете модификатор C</s>, который фактически сообщает Perl,
  что весь буфер для поиска - это одна строка --даже если это не так.
X<.> X</s>

=head3 Повторители (Квантификаторы, умножители, символы, указывающие количество)

Существуют следующие стандартные повторители:
X<метасимвол> X<повторитель> X<*> X<+> X<?> X<{n}> X<{n,}> X<{n,m}>

    *           Найдет 0 или больше раз
    +           Найдет 1 или больше раз
    ?           Найдет 1 или 0 раз
    {n}         Найдет точно n раз
    {n,}        Найдет по крайней мере n раз
    {n,m}       Найдет по крайней мере n раз, но не более m раз

(Если фигурная скобка находится в любом другом контексте и не являются частью
эскейп последовательности такой, как  C<\x{...}>, то она обрабатывается как обычный
символ. В частности, нижняя граница повторителя не является обязательной,
опечатка в повторителе молча рассматривает его, как
буквенные символы. Например,

    /o{4,3}/

выглядит как повторитель, который найдется 0 раз, так как 4 больше 3,
но это в действительности это означает соответствие последовательности из шести символов
S<C<"o { 4 , 3 }">>.  
Запланировано в конечном счете потребовать буквального использования
из фигурных скобок, которых будут заэкранированы, скажите, поставив перед ними обратную косую черту
или поставив их квадратные скобки,
, (C<"\{"> или C<"[{]">).  
Это изменение будет допускать будущее расширения синтаксиса (как создание нижней границы
повторителя, как опциональное), и лучшей проверки на ошибки. Тем временем 
вы должны привыкнуть избегать всех случаев, где
вы имеете в виду символ "{".)

Повторитель "*" означает тоже, что и C<{0,}>, повторитель "+"
это C<{1,}>, и "?" это C<{0,1}>.  n и m ограничены
неотрицательными значениями меньше, чем заданный предел, определенный во время сборки perl.
Это обычно 32766 на наиболее распространенных платформах. Фактический предел может
будьте найден в сообщении об ошибке, произведенном следующим кодом:

    $_ **= $_ , / {$_} / for 2 .. 42;

По умолчанию повторительный подшаблон "жадный", это означает, что он будет искать
максимальное число совпадений из возможного (начиная с указанной стартовой позиции)
пока еще соответствие шаблону остается.  Если вы хотите найти минимальное число совпадений
, укажите после повторителя "?".  Следует что значение шаблона не меняется,
а только его "жадность":
X<метасимвол> X<жадный> X<жадность>
X<?> X<*?> X<+?> X<??> X<{n}?> X<{n,}?> X<{n,m}?>

    *?        Найдёт 0 или больше раз, не жаден
    +?        Найдёт 1 или больше раз, не жаден
    ??        Найдёт 0 или 1 раз, не жаден
    {n}?      Найдёт точно n раз, не жаден (излишне)
    {n,}?     Найдёт как минимум n раз, не жаден
    {n,m}?    Найдёт как минимум n раз но не более m раз, не жаден

По умолчанию, когда повторенный вложенный шаблон не позволяет совпасть остальной части
общего шаблона, Perl делает шаг назад (backtrack). Однако такое поведение является
иногда нежелательно. Тогда Perl предоставляет форму "притяжательного" повторителя.

 *+     Найдёт 0 или больше раз и не дает возврата
 ++     Найдёт 1 или больше раз и не дает возврата
 ?+     Найдёт 0 или 1 раз и не дает возврата
 {n}+   Найдёт точно n раз и не дает возврата (излишне)
 {n,}+  Найдёт как минимум n раз и не дает возврата
 {n,m}+ Найдёт как минимум n раз но не более m раз и не дает возврата

Например,

   'aaaa' =~ /a++a/

никогда не найдется, так как C<a++> будет съедать все C<a> в
строке и не оставит ни одного символа для оставшейся части шаблона. 
Эта особенность может быть экстремально полезна, давая перлу сигнал, 
где не должно быть возврата назад. Например, типичная проблема "поиска строки в двойных кавычках"
 может решиться наиболее эффективно, когда написано так:

   /"(?:[^"\\]++|\\.)*+"/

как мы знаем, если последняя кавычка не находится, то поиск с возвратом не поможет.

Смотри независимое выражение
L</C<< (?>pattern) >>> для деталей;
притяжательные повторители являются только синтаксическим сахаром для этой конструкции. Например, 
пример, приведенный выше, может быть записан следующим образом:

   /"(?>(?:(?>[^"\\]+)|\\.)*)"/

=head3 Эскейп последовательности (или последовательности обратной косой черты)

Поскольку шаблоны обрабатываются, как строки в двойных кавычках, то следующие
последовательности также будут работать:

 \t          табуляция                   (HT, TAB)
 \n          новая строка               (LF, NL)
 \r          ввод, перенос строки                (CR)
 \f          Перевод формата (Formfeed)             (FF)
 \a          Тревога (звуковой сигнал)          (BEL)
 \e          Клавиша ESC (Escape) (think troff)  (ESC)
 \cK         символ control          (пример: VT)
 \x{}, \x00  порядковый номер символа, данный в шестнадцатеричном формате
 \N{name}    Именованный символ Юникода или последовательность символов
 \N{U+263D}  Юникодный символ     (пример: FIRST QUARTER MOON)
 \o{}, \000  порядковый номер символа, данный в восьмеричном формате
 \l          Следующий символ в нижнем регистре (думая vi)
 \u          Следующий символ в верхнем регистре (думая vi)
 \L          Нижний регистр до \E (думая vi)
 \U          Верхний регистр до \E (думая vi)
 \Q          (quote) Отключает действие метасимволов в шаблоне до \E
 \E          Завершение модификации, конец случае модификации или заквотированной секции, думая vi

Подробнее смотри L<perlop/"Квотирование и Операторы заключения в кавычки"> (L<perlop/Quote and Quote-like Operators>).

=head3 Символьные типы и другие специальные эскейп символы

Кроме того Perl определяет следующее:
X<\g> X<\k> X<\K> X<backreference>

 Последовательность   Замечание    Описание
  [...]     [1]  Найдет символ, который соответствует правилу в квадратных скобках,
                 определенный "...".
                   Например: [a-z] найдет "a" или "b" или "c" ... или "z"
  [[:...:]] [2]  Найдет символ, который соответствует правилам POSIX
                    "..." класса символов в двойных квадратных скобках. Например: [[:upper:]] найдет любой 
                    символ в верхнем регистре.
  (?[...])  [8]  Расширенный класс символов в скобках
  \w        [3]  Найдет символ "слова" (буквацифра плюс "_", плюс
                  другие соединительные знаки пунктуации, отметки Юникода)
  \W        [3]  Найдет символ не-"слова"
  \s        [3]  Найдет пробельный символ
  \S        [3]  Найдет не пробельный символ
  \d        [3]  Найдет символ десятичной цифры
  \D        [3]  Найдет отрицание символа десятичной цифры
  \pP       [3]  Найдет P, именованное свойство. Используйте \p{Prop} для длинных имен
  \PP       [3]  Найдет не-P
  \X        [4]  Найдет Юникодный "расширенный графема кластер"
  \C             Найдет один символ из языка C (октет - 8 бит,  1 байт) даже, если он часть
                   большого UTF-8 символа.  Таким образом он ломает символы в их байты из UTF-8, так что вы можете 
                   получить искаженные кусочки(malformed pieces) UTF-8.
                   Не поддерживается в поиске вперед.
  \1        [5]  Обратная ссылка на конкретную группу или буфер.
                   '1' на самом деле может быть любое положительное целое число.
  \g1       [5]  Обратная ссылка на конкретную или предыдущую группу,
  \g{-1}    [5]  Числа могут быть отрицательными, указывать относительно
                  предыдущей группы и при необходимости могут быть обернуты в
                  фигурные скобки для безопасного синтаксического разбора.
  \g{name}  [5]  Именованная обратная ссылка
  \k<name>  [5]  Именованная обратная ссылка
  \K        [6]  Сохраняет найденный материал слева от \K, не включая его в $&
  \N        [7]  Любой символ, кроме \n.  Не влияет на модификатор /s
  \v        [3]  Вертикальный пробел
  \V        [3]  Невертикальный пробел
  \h        [3]  Горизонтальный пробел
  \H        [3]  Негоризонтальный пробел
  \R        [4]  Универсальная новая строка

=over 4

=item [1]

См. L<perlrecharclass/Bracketed Character Classes> для деталей.

=item [2]

См. L<perlrecharclass/POSIX Character Classes> для деталей.

=item [3]

См. L<perlrecharclass/Backslash sequences> для деталей.

=item [4]

См. L<perlrebackslash/Misc> для деталей.

=item [5]

См. L</Группы захвата> ниже для деталей.

=item [6]

См. L</Расширенные шаблоны поиска> ниже для деталей.

=item [7]

Обратите внимание, что C<\N> имеет два значения. Когда он в форме C<\N{NAME}>, он соответствует
символу или последовательности символов, которые называются C<NAME>; и так же,
когда форма C<\N{U+I<hex>}>, она соответствует символу Юникода, в шестнадцатеричном коде
— <hex>. В противном случае он соответствует любому символу, кроме C<\n>.

=item [8]

See L<perlrecharclass/Расширенная классы скобочных символов (Extended Bracketed Character Classes)> для деталей.

=back

=head3 Утверждения

Perl определяет следующие утверждения нулевой длины:
X<утверждения нулевой длины> X<утверждения> X<регексы, утверждения нулевой длины>
X<регекспы, утверждения нулевой длины>
X<регулярные выражения, утверждения нулевой длины>
X<\b> X<\B> X<\A> X<\Z> X<\z> X<\G>

    \b  Найдет границу слова
    \B  Найдет все, кроме границы слова
    \A  Найдет начало строки
    \Z  Найдет только в конце строки или перед новой строкой в конце
    \z  Найдет только в конце строки
    \G  Найдет только в pos() (т.е. в конце последней найденной позиции m//g)

Граница слова (C<\b>) это место между двумя символами,
которые содержат C<\w> на одной их стороне и  C<\W> на другой
 (в любом порядке), считая воображаемые символы начала и конца строки, как C<\W>.
  (Внутри сивольных классов C<\b> 
  представляет клавишу backspace, а не границу слова,так, как это обычно бывает в любой строке в двойных кавычках.)
C<\A> и C<\Z> работают также, как и "^" и "$", за исключением того, что они
не будут искать несколько раз, когда используется модификатор C</m>
, тогда как
"^" и "$" будут соответствовать каждой внутренней линии границы. 
Чтобы найти актуальный конец строки и не игнорировать 
дополнительные конечные строки, используйте C<\z>.
X<\b> X<\A> X<\Z> X<\z> X</m>

Утверждение C<\G> можно использовать для глобального поиска (используя
C<m//g>), как описано в L<perlop/"Квотирование и Операторы заключения в кавычки"> (L<perlop/Quote and Quote-like Operators>).
Это также удобно во время написания C<lex>-подобных сканеров, когда у вас есть несколько паттернов,
 которым вы хотите сопоставить последующие подстроки строки;
 cмотрите предыдущие ссылки. 
 Фактическое местонахождение, где C<\G> будет находить, 
 также может определяться с помощью C<pos()> как lvalue(левое значение): см. L<perlfunc/pos>.
 Обратите внимание, что правило нулевой длины
 (см.  L</"Повторяющиеся шаблоны, находящие подстроки нулевой длины">
 (L</"Repeated Patterns Matching a Zero-length Substring">))
изменяется несколько в том, что содержимое слева от C<\G>
не учитываются при определении длины найденного. Таким образом следующее
никогда не будет соответствовать:
X<\G>

     my $string = 'ABC';
     pos($string) = 1;
     while ($string =~ /(.\G)/g) {
         print $1;
     }

Он напечатает 'A' и остановиться, т.к. будет считаться, что был поиск
 нулевой ширины и таким образом - он не будет соответствовать одной и той же позиции дважды в
строке.

Стоит отметить, что C<\G> при не правильном использовании может привести к бесконечному
циклу. Будьте осторожны при использовании шаблонов, которые включают C<\G> как альтернативу.

=head3 Группы захвата

Скобочная конструкция C<( ... )> создаёт группы захвата (также именуется как
буферы захвата). Чтобы сослаться на текущее содержимое группы позже в пределах
текущего шаблона поиска нужно использовать C<\g1> (или C<\g{1}>) для первой, C<\g2> (или C<\g{2}>)
для второй группы и так далее.
Это называется I<обратной ссылкой> (I<backreference>).
X<регекс, буфер захвата> X<регексп, буфер захвата>
X<регекс, группа захвата> X<регексп, группа захвата>
X<регулярное выражение, буфер захвата> X<обратная ссылка>
X<регулярное выражение, группа захвата> X<backreference>
X<\g{1}> X<\g{-1}> X<\g{name}> X<относительная обратная ссылка> X<именованная обратная ссылка>
X<именованный буфер захвата> X<регулярное выражение, именованный буфер захвата>
X<именованная группа захвата> X<регулярное выражение, именованная группа захвата>

X<regex, capture buffer> X<regexp, capture buffer>
X<regex, capture group> X<regexp, capture group>
X<regular expression, capture buffer> X<backreference>
X<regular expression, capture group> X<backreference>
X<\g{1}> X<\g{-1}> X<\g{name}> X<relative backreference> X<named backreference>
X<named capture buffer> X<regular expression, named capture buffer>
X<named capture group> X<regular expression, named capture group>
X<%+> X<$+{name}> X<< \k<name> >>
Количество захваченных подстрок, которые вы можете использовать не ограничено.
Группы нумеруются с левой открывающей круглой скобки номер 1, и т.д. Если
группа не найдена, связанные обратные ссылки тоже не будут совпадать. (Это
может случиться, если группа не является обязательной, или поиск идет в альтернативной ветке).
Вы можете опустить C<"g"> и написать C<"\1">, и т.д., но с этим есть некоторые проблемы, описанные ниже.

Также можно захватывать группы относительно друг друга, используя отрицательное число, так 
С<\g-1> и С<\g{-1}> оба относятся к группе непосредственно перед захватом и 
C<\g-2> и C<\g{-2}> относятся к группе перед ней. Например:

        /
         (Y)            # группа 1
         (              # группа 2
            (X)         # группа 3
            \g{-1}      # обратная ссылка на группу 3
            \g{-3}      # обратная ссылка на группу 1
         )
        /x

поиск будет таким же, как C</(Y) ( (X) \g3 \g1 )/x>. Это позволяет
интерполировать регулярные выражения в большие регулярные выражения
и тогда не придется беспокоиться о перенумерации групп захвата.

Можно вообще обойтись числами и создать именованные группы захвата.
Нужно объявить C<(?E<lt>I<name>E<gt>...)> и C<\g{I<name>}> для такой
ссылки. (Чтобы быть совместимым с регулярные выражения .Net, C<\g{I<name>}> 
также может быть написано как C<\k{I<name>}>,  C<\kE<lt>I<name>E<gt>> или C<\k'I<name>'>.)
I<name> не должно начинаться с цифры или содержать дефисы.
Если несколько групп в рамках шаблона имеют одинаковое имя, то любая ссылка
 на это имя подразумевает самую левую определяемую группу. Именованные группы учитываются и в
абсолютной и в относительной нумерации и на них также можно сослаться с помощью номера.

(Это делает возможным делать вещи с именованными группами захвата, которые бы в противном случае
требовали бы C<(??{})>.)

Содержимое захваченной группы определяется динамически и оно доступно для вас вне
 шаблона поиска до конца закрывающего блока или до следующего успешного
поиска, что наступит раньше. (См. L<perlsyn/"Составные операторы">.)
Вы можете обращаться к ним по абсолютному номеру (используя C<"$1"> вместо C<"\g1">,
и т.д.); или по имени через хэш  C<%+>, с помощью C<"$+{I<name>}">.

Скобки требуются для ссылки на именованные группы захвата, но являются опциональными для
абсолютной или относительной нумерации групп. Скобки являются более безопасными, когда создается регулярное выражение
объединение меньших строк. Например, если у вас есть C<qr/$a$b/> и C<$a>
содержит C<"\g1">, и  C<$b>  содержит C<"37">, вы получите C</\g137/>, что является, вероятно, не тем,
 что вы хотели.

Обозначения C<\g> и C<\k> были введены в Perl 5.10.0. До этого
не было ни именованных, ни относительно пронумерованных групп захвата. Абсолютная нумерация
группы передавалась с помощью C<\1>,
C<\2> и т.д., и эта запись до сих пор
принимается (и скорее всего всегда будет). Но это приводит к некоторым неясностям, если
есть более чем 9 групп захвата, так C<\10> может означать либо десятую
группу захвата, или символ, чей порядковый номер восьмеричное-010 (бэкспейс (пробел назад) в
ASCII). Perl разрешает эту неопределенность путем интерпретации  C<\10> как обратной ссылки
только, если по крайней мере 10 левых скобок были открыты перед ней. Аналогичным образом, C<\11>
 - это обратная ссылка только, если по крайней мере 11 левых скобок открыты перед ней.
И так далее. От C<\1> до C<\9> всегда интерпретируются как обратные ссылки.
Есть несколько примеров ниже, которые иллюстрируют эти риски. Вы можете избежать
двусмысленности всегда используя C<\g{}> или C<\g>, если вы имеете в виду захватываемые группы;
и для восьмеричных констант всегда использовать C<\o{}>, или для C<\077> и ниже, используя 3
цифры с ведущими нулями, поскольку лидирующий ноль означает восьмеричную
константу.

Обозначения C<\I<digit>> также работает в определенных обстоятельствах за пределами
шаблона. Смотри  L</Предупреждение на \1 вместо $1> ниже для деталей.

Examples:

    s/^([^ ]*) *([^ ]*)/$2 $1/;     # поменять местами первые два слова

    /(.)\g1/                        # найдет первый дублирующий символ
         and print "'$1' is the first doubled character\n";

    /(?<char>.)\k<char>/            # ... другой способ
         and print "'$+{char}' is the first doubled character\n";

    /(?'char'.)\g1/                 # ... смешанный поиск
         and print "'$1' is the first doubled character\n";

    if (/Time: (..):(..):(..)/) {   # разобрать значения
        $hours = $1;
        $minutes = $2;
        $seconds = $3;
    }

    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\g10/   # \g10 - это обратная ссылка
    /(.)(.)(.)(.)(.)(.)(.)(.)(.)\10/    # \10 - восьмеричное число
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\10/  # \10 - это обратная ссылка
    /((.)(.)(.)(.)(.)(.)(.)(.)(.))\010/ # \010 - восьмеричное число

    $a = '(.)\1';        # Создает проблемы, когда объединяются.
    $b = '(.)\g{1}';     # Позволяет избежать проблем.
    "aa" =~ /${a}/;      # Правда
    "aa" =~ /${b}/;      # Правда
    "aa0" =~ /${a}0/;    # Ложь!
    "aa0" =~ /${b}0/;    # Правда
    "aa\x08" =~ /${a}0/;  # Правда!
    "aa\x08" =~ /${b}0/;  # Ложь

Несколько специальных переменных также вернут порцию предыдущего поиска.
 C<$+> вернет результат найденного в последней скобке.
C<$&> вернет всю совпадающую строку. (Раньше это делал  C<$0>,
 но теперь он возвращает имя программы.) C<$`> вернет 
все перед совпавшей строкой.C<$'> вернет все
после совпавшей строки. И C<$^N> содержит все, что было найдено 
в самой недавно закрытой группе (подстроку). C<$^N> может быть использован в
расширенные шаблонах (см. ниже), например назначить найденную подстроку 
переменной.
X<$+> X<$^N> X<$&> X<$`> X<$'>

Существуют специальные переменные такие как хеш C<%+> и пронумерованные переменные поиска
(C<$1>, C<$2>, C<$3>, и т.д.) динамически распространяющиеся 
до конца закрывающего блока или до следующего успешного поиска,
 что наступит раньше.  (См. L<perlsyn/"Составные операторы">.) (См. L<perlsyn/"Compound Statements">.)
X<$+> X<$^N> X<$&> X<$`> X<$'>
X<$1> X<$2> X<$3> X<$4> X<$5> X<$6> X<$7> X<$8> X<$9>

B<ЗАМЕЧАНИЕ>: неудачные поиски в Perl не сбрасывают переменные поиска,
что упрощает написание кода, который проверяет серию
конкретных случаев и запоминает лучший поиск.

B<ПРЕДУПРЕЖДЕНИЕ>: как только Perl видит, что вам нужна одна из переменных 
C<$&>, C<$`>, или C<$'> где-либо в программе, он должен предоставить их для каждого
поиска по шаблону. Это может существенно замедлить вашу программу. Perl
использует тот же механизм для производства  C<$1>, C<$2>, и т.д., так, что вы также платите
существенную цену для каждого шаблона, который содержит захватывающие скобки. (Чтобы
избежать этой платы при сохранении группирующего поведения, используйте
вместо этого расширенное регулярное выражение C<(?: ... )> .) Но если вы никогда не
используете  C<$&>, C<$`> или C<$'>, тогда шаблоны I<без> захватывающих
скобок не будут наказаны. Поэтому избегайте C<$&>, C<$'>, или C<$`>,
если можете, но если вы не можете (и я очень ценю некоторые такие алгоритмы),
 после того как вы использовали их один раз, использовать их по своему желанию, потому что вы
уже за низ заплатили. По состоянию на 5.17.4, присутствие каждой из трех
переменных в программе регистрируется отдельно и, в зависимости от
обстоятельства, perl может быть в состоянии быть более эффективным зная что только  C<$&>
, а не все три будут использованы, например.
X<$&> X<$`> X<$'>

Для того, чтобы обойти эту проблему Perl 5.10.0 представляет переменные  C<${^PREMATCH}>,
C<${^MATCH}> и C<${^POSTMATCH}>, которые эквивалентны  C<$`>, C<$&>
и C<$'>, B<исключая> то, что только они будут гарантированно определены после
успешного поиска, который был выполнен с модификатором C</p> (preserve) (сохранять) .
Использование этих переменных не влечет к штрафу глобальной производительности, в отличие от
их эквивалента в виде знаков препинания, однако здесь вы идете на компромисс того, что вы
должны сказать perl, когда вы хотите их использовать.
X</p> X<p модификатор>

=head2 Квотирующие метасимволы (Quoting metacharacters)

Метасимволы с обратным слэшем в Perl являются буквенно-цифровыми, например C<\b>,
C<\w>, C<\n>. В отличие от некоторых других языков с регулярными выражениями, не существует
символов с обратным слэшем, которые не являются буквенно-цифровыми. Так что все, что
  выглядит как \\, \(, \), \ [, \], \ {, или \} всегда
интерпретируется как буквенный символ, а не метасимвол. Это было
некогда общей идеей для отключения или квотирования (оборачивание в кавычки) метасимволов, имеющих специальное значение
 в регулярных выражениях, которых вы хотите
использовать для шаблоне поиска. Теперь заквотируем (поставим обратный слэш) для всех не-"словесных" символов:

    $pattern =~ s/(\W)/\\$1/g;

(Если установлено C<use locale>, то это зависит от текущей локали.)
Сегодня чаще используют функцию quotemeta() или С<\Q>
метаквотированный эскейп символ для отключения специальных
значений всех метасимволов следующим образом:

    /$unquoted\Q$quoted\E$unquoted/

Учтите, что если вы положите символ косой черты (который не внутри
переменных с интерполяцией) между C<\Q> и C<\E>, двойное квотирование
интерполяции обратной косой черты может привести к нежелательным результатам. Если вам
I<нужно> использовать символ косой черты в пределах C<\Q...\E>,
проконсультируйтесь с (L<perlop/"Кровавые подробности разбора закавыченных(квотированных) конструкций">) (L<perlop/"Gory details of parsing quoted constructs">).

C<quotemeta()> и C<\Q> полностью описаны в L<perlfunc/quotemeta>.

=head2 Расширенные шаблоны

Perl также определяет синтаксис последовательного расширения функций не
 входящих в стандартные инструменты, такие как B<awk> и B<lex>. 
Синтаксис для большинства из них - это пара скобок с вопросительным знаком идущим сразу 
за первой скобкой. Символ идущий за вопросительным знаком указывает
расширение.

Стабильность этих расширений колеблется в широких пределах. Некоторые из них были
частью основного языка на протяжении многих лет. Другие экспериментальные
и могут меняться без предупреждения или быть полностью удалены. Проверяйте
документацию для каждого компонента для проверки его текущего
статуса.

Вопросительный знак был выбран для этого и для минимального соответствия
конструкции потому что 1) вопросительные знаки встречаются редко в старых регулярных
выражения и 2) всякий раз, когда вы его видите, вы должны остановиться и
"задаться вопросом" точности того, что происходит. Это психология...

=over 4

=item C<(?#text)>
X<(?#)>

Комментарий. Текст игнорируется. Если модификатор C</x>  позволяет
использование пробельных символов для форматирования, то простого C<#> будет достаточно. 
Обратите внимание, что Perl закрывает комментарий, как только он видит  C<)>, 
так что нет никакого способа положить литерал (символ)
C<)> в комментарий.

=item C<(?adlupimsx-imsx)>

=item C<(?^alupimsx)>
X<(?)> X<(?^)>

Один или несколько встроенных модификаторов в шаблон, чтобы быть включенным (или
выключенным, если предшествует C<->) на оставшуюся часть шаблона или
оставшуюся часть закрытой группы поиска(если таковые имеются).

Это особенно полезно для динамических шаблонов, например, которые читаются из
файла конфигурации, взяты из аргумента, или указаны в таблице
где-либо. Рассмотрим случай, когда некоторые шаблоны хотят быть
с учетом регистра,а другие нет: для того, чтобы поиска части шаблона был 
без учета регистра, то необходимо
включить C<(?i)> перед шаблоном. Например:

    $pattern = "foobar";
    if ( /$pattern/i ) { }

    # более гибко:

    $pattern = "(?i)foobar";
    if ( /$pattern/ ) { }

These modifiers are restored at the end of the enclosing group. For example,
Эти модификаторы восстанавливаются в конце внешней группы. Например,

    ( (?i) blah ) \s+ \g1

который найдет C<blah> в любом регистре, 
некоторые пробелы и точное (I<включая регистр>!)
повторение предыдущего слова, предполагая модификатор C</x>, а теперь нет модификатора C</i>
 за пределами этой группы.

Эти модификаторы не переносятся в именованные подмаски, вызванные в закрытой группе. 
Другими словами шаблон например C<((?i)(?&NAME))> не
изменяет чувствительности регистра для шаблона "NAME".

Любой из этих модификаторов можно установить, что применить его
 глобально для всех регулярных выражений,
  скомпилированные в сфере  C<use re>. 
  См. L<re/"'/flags' mode">.

Начиная с Perl 5.14, C<"^"> (курсор или диакритический акцент) сразу за
 C<"?"> это сокращение соответствует C<d-imsx>.  Флаги (кроме
C<"d">) могут следовать после курсора для переопределения.
Но минус не является легальным с ним.

Учтите, что модификаторы C<a>, C<d>, C<l>, C<p>, и C<u> являются специальными
 здесь они могут быть включены, не не выключены, а модификаторы C<a>, C<d>, C<l>, и
C<u> являются взаимоисключающими: указав один вы отрицаете другой,
 и максимум один из них (или два C<a>) может появится в этой конструкции.
 Таким образом, C<(?-p)> предупредит при компиляции при C<use warnings>;
C<(?-d:...)> и C<(?dl:...)> дадут фатальную ошибку.

Также, обратите внимание, что модификатор C<p> имеет особое значение в том, что его присутствие
в любом месте в шаблоне имеет глобальный эффект.

=item C<(?:pattern)>
X<(?:)>

=item C<(?adluimsx-imsx:pattern)>

=item C<(?^aluimsx:pattern)>
X<(?^:)>

Это для кластеризации, но не для захвата; он группирует подвыражения как
"()", но не делает обратной ссылки, как это делает "()". Так что

    @fields = split(/\b(?:a|b|c)\b/)

подобно

    @fields = split(/\b(a|b|c)\b/)

но не выплевывает дополнительные поля. Также дешевле не захватывать группы
, если вам не нужно.

Любые символы между C<?> и C<:> действуют как флаги модификаторов, такие как
C<(?adluimsx-imsx)>. Например,

    /(?s-i:more.*than).*million/i

эквивалентно более подробному

    /(?:(?s-i)more.*than).*million/i

Начиная с Perl 5.14, C<"^"> (курсор или диакритический акцент) сразу за
 C<"?"> это сокращение соответствует C<d-imsx>.  Любые позитивные флаги (кроме
C<"d">) могут следовать после курсора, таким образом

    (?^x:foo)

эквивалентно

    (?x-ims:foo)

Курсор рассказывает Perl, что этот кластер не наследует флаги любых
окружающих шаблонов, но использует системные умолчания (C<d-imsx>),
измененные любыми указанными флагами.

Курсор позволяет упростить создание строчек (stringification) из скомпилированных регулярных
выражений. Они выглядят как

    (?^:pattern)

с любыми флагами не по умолчанию, появляющимися между курсором и двоеточием.
Тест, который выглядит, как перевод в строку (stringification), таким образом, не нуждается в 
в флагах по умолчанию, жестко зашитых в нем, только курсор. Если новые флаги
будут добавлены в Perl, смысл курсора расширения  изменится включением
флагов по умолчанию, поэтому тест все еще будет работать, без изменений.

Указание отрицательных флага, после курсора C<^>, является ошибкой, т.к. как флаг
 является излишним.
 
Мнемоника для C<(?^...)>: свежее начало, поскольку галка обычно используется для
поиска начала.

=item C<(?|pattern)>
X<(?|)> X<Branch reset>

Это "сброс ветки" шаблона, который имеет специальные свойства, 
когда захватываемые группы нумеруются с той же начальной точки
в каждой чередующейся ветке . Он доступен начиная с perl 5.10.0.

Группы захвата  нумеруются слева направо, но внутри этой
конструкции нумерация возобновляется для каждой ветви.

Нумерация в пределах каждой ветки будет нормальной и все группы
следующие за этой конструкцией будут пронумерованы так,как-будто бы конструкция
содержится только одну ветвь, ту, которая попадет в группу захвата.

Эта конструкция является полезной, когда вы хотите захватить одну из
 нескольких альтернативных групп.

Рассмотрим следующий шаблон. Цифры над под выражением
 показывают номера групп захвата.

    # before  ---------------branch-reset----------- after        
    / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
    # 1            2         2  3        2     3     4  

Будьте внимательны при использовании сброса ветки шаблона в сочетании с
именем захвата. Именованные захваты реализованы как псевдонимы
нумерованным группам, что мешает
осуществлению сброса ветки шаблона. Если вы используете именованный захват
 в сбросе ветки шаблона, то лучше использовать те же имена,
в том же порядке, в каждом из альтернатив:

   /(?|  (?<a> x ) (?<b> y )
      |  (?<a> z ) (?<b> w )) /x

Не делайте так, это может привести к сюрпризам:

  "12" =~ /(?| (?<a> \d+ ) | (?<b> \D+))/x;
  say $+ {a};   # Prints '12'
  say $+ {b};   # *Also* prints '12'.

Проблема здесь в том, что обе группы назвали  C<< a >>, а группа с
именем C<< b >> является алиасом для группы, принадлежащей к  C<< $1 >>.

=item Утверждения Осмотра Вокруг (Look-Around Assertions)
X<утверждения окружения>X<look-around assertion> X<lookaround assertion> X<look-around> X<lookaround>

Утверждения Осмотра Вокруг представляют собой шаблоны нулевой ширины,
которые находя специфические элементы без включения результата в  C<$&>. 
Позитивные утверждения находятся, когда подмаски находятся,
отрицательные утверждения находятся, когда поиск по подмаске не удачный. 
Осмотр-До(look-behind) находит текст до текущей позиции,
Осмотр-После(look-ahead) находит текст следующий за позицией поиска.

=over 4

=item C<(?=pattern)>
X<(?=)> X<look-ahead, positive> X<lookahead, positive>

Позитивное нулевой ширины утверждение поиска вперед.  
Например, C</\w+(?=\t)/>
найдет слово, за которым следует табуляция
 без включения таба в C<$&>.

=item C<(?!pattern)>
X<(?!)> X<look-ahead, negative> X<lookahead, negative>

Негативное нулевой ширины утверждение поиска вперед.  
Например C</foo(?!bar)/>
найдет любое вхождение "foo" за которым не следует "bar". 
Замечание.
Однако поиск вперед и назад не то же самое. Вы не можете
использовать это для поиска назад.

Если вы ищете "bar" перед которым нет "foo", C</(?!foo)bar/>
, то будет искаться не то, что вы хотите.
Потому что C<(?!foo)> означает, что следующая вещь
 не может быть "foo"--но это не так, это "bar", таким образом "foobar" будет найден. 
 Используйте вместо этого поиск назад (смотрите ниже).

=item C<(?<=pattern)> C<\K>
X<(?<=)> X<look-behind, positive> X<lookbehind, positive> X<\K>

Позитивное нулевой ширины утверждение поиска назад.  
Например, C</(?<=\t)\w+/>
найдет слово, перед которым стоит таб, без включения таба в C<$&>.
Работает только для поиска назад фиксированной длины.

Существует специальная форма этой конструкции, называемая C<\K>, которая влияет на
регекс движок таким образом, что он "сохраняет" все, что было найдено перед C<\K>
и не включает это в C<$&>. Это обеспечивает эффективный поиск назад переменной длины.
Использования C<\K> внутри другого утверждения Осмотра Вокруг возможно, но это поведение
еще хорошо не определено.

Для различных причин C<\K> может быть значительно более эффективным, чем
эквивалентная конструкция C<< (?<=...) >> и он особенно полезен в
ситуации, где вы хотите эффективно удалить что-то следующее после строки. 
К примеру 

  s/(foo)bar/$1/g;

можно переписать гораздо более эффективно

  s/foo\Kbar//g;

=item C<(?<!pattern)>
X<(?<!)> X<look-behind, negative> X<lookbehind, negative>

Отрицающее утверждение нулевой ширины поиска назад.  
Например C</(?<!bar)foo/>
 найдет вхождения "foo" , которые не следуют за "bar".  Работает
только для поиска назад фиксированной длины.

=back

=item C<(?'NAME'pattern)>

=item C<< (?<NAME>pattern) >>
X<< (?<NAME>) >> X<(?'NAME')> X<named capture> X<capture>

Имя захваченной группы.
Идентично во всех отношениях для нормального захвата
скобками C<()>, но есть для дополнительной факт то, что к группе
можно обращаться по имени в различных конструкциях регулярных выражений
 (например, C<\g{NAME}>) и может быть доступен по имени
после успешного поиска через C<%+> или C<%->. См. L<perlvar>
для более подробной информации о хэшах C<%+> и C<%->.

Если несколько различных захватываемых групп  имеют одинаковые имена, то
$+{NAME} будет ссылаться на самую левую и этих групп.

Формы C<(?'NAME'pattern)> и C<< (?<NAME>pattern) >> эквивалентны.

B<ПРИМЕЧАНИЕ:> Хотя нотация этой конструкции такая же, как в регексах .NET , 
но поведение не совпадает. В Perl являются группы
нумеруются последовательно, независимо от того именованные они или нет. 
Таким образом, в шаблоне

  /(x)(?<foo>y)(z)/

$+{foo} будет тоже, что и $2, и $3 будет содержать 'z' 
вместо того, что хакер .NET регекса мог бы ожидать.

В настоящее время имя ограничивается простым идентификатором.
Другими словами, он должен совпадать с  C</^[_A-Za-z][_A-Za-z0-9]*\z/>  или
его Юникодным расширением (см. L<utf8>)
хотя он не поддерживает докали (locale) (см. L<perllocale>).

B<ПРИМЕЧАНИЕ:> для того, чтобы сделать вещи проще для программистов с опытом работы
с Python или движком регексов PCRE, шаблон C<< (?PE<lt>NAMEE<gt>pattern) >>
может быть использован вместо C<< (?<NAME>pattern) >>; Однако эта форма не
поддерживает использование одинарных кавычек в качестве разделителя для имени.

=item C<< \k<NAME> >>

=item C<< \k'NAME' >>

Именованная обратная ссылка. Похожа на цифровую обратную ссылку за исключением случаев
, когда группа обозначается именем, а не числом. Если несколько групп
имеют то же имя, то оно относится к самой левой найденной группе в
текущем поиске.

Будет сообщение об ошибке, если будет ссылка на имя не определенное  C << (? <NAME>) >>
ранее в шаблоне.

Обе формы являются эквивалентными.

B<ПРИМЕЧАНИЕ:> для того, чтобы сделать вещи проще для программистов с опытом работы
с Python или движком регексов PCRE, шаблон C<< (?P=NAME) >>
может быть использован вместо C<< \k<NAME> >>.

=item C<(?{ code })>
X<(?{})> X<regex, code in> X<regexp, code in> X<regular expression, code in>

B<ПРЕДУПРЕЖДЕНИЕ>: Эта функция расширенных регулярных выражений считается
экспериментальной и может быть изменена без предварительного уведомления. Выполняемый код 
имеет побочные эффекты, которые могут быть не одинаковыми от версии к версии
из-за эффекта будущего оптимизаций в движке регексов (regex engine). Для
осуществление этой функции был радикально пересмотрен 5.18.0 релиз
и его поведение в более ранних версиях perl было намного более бажное (с большим числом багов),
особенно в отношении разбора, лексических переменных, их действия, рекурсии и
повторного входа (to parsing, lexical vars, scoping, recursion and
reentrancy).

Это утверждение нулевой ширины выполняет любой встроенный код Perl. Оно всегда
завершается успешно, и ее возвращаемое значение устанавливается как  C<$^R>.

В буквенных шаблонах, код парсится в то же время, как
окружающий код. Во время обработки шаблона управление временно передаётся 
 анализатору perl пока не находится закрывающая скобка.
Это похоже путь, которым индекс массива
 вытаскивает строку, например

    "abc$array[ 1 + f('[') + g()]def"

В частности, скобки не обязательно должны быть сбалансированы:

    s/abc(?{ f('{'); })/def/

Даже, если шаблон является интерполяцией и компилируется во время выполнения, литеральные
блоки кода компилируются один раз, во время компиляции perl; следующее
печатает "ABCD":

    print "D";
    my $qr = qr/(?{ BEGIN { print "A" } })/;
    my $foo = "foo";
    /$foo$qr(?{ BEGIN { print "B" } })/;
    BEGIN { print "C" }

В шаблонах, где текст кода является производным от информации времени выполнения
, а не появляется буквально в исходном коде /шаблоне/,
код компилируется в то же время, что и шаблон, и,
по соображениям безопасности, C<use re 'eval'> должен быть в области. 
Это нужно для остановки пользовательских шаблонов, содержащие фрагменты кода,
которые будут выполнены.

В ситуациях, когда вам нужно включить это с C<use re 'eval'> вы должны
также включить проверку на чужеродные примеси в коде( taint )
 Еще лучше, используйте аккуратно ограничения выполнения в рамках безопасного отсека (Safe compartment.). 
Смотрите L<perlsec> для деталей работы обоих этих механизмов.

С точки зрения анализа, лексическая область видимости переменной и замыканий (closures),

    /AAA(?{ BBB })CCC/

ведет себя примерно как

    /AAA/ && do { BBB } && /CCC/

Аналогичным образом,

    qr/AAA(?{ BBB })CCC/

ведет себя примерно как

    sub { /AAA/ && do { BBB } && /CCC/ }

В частности:

    { my $i = 1; $r = qr/(?{ print $i })/ }
    my $i = 2;
    /$r/; # prints "1"

Внутри блока C<(?{...})>, C<$_> относится к строке регулярного
выражения стоящего напротив. Вы также можете использовать C<pos()>, чтобы узнать
текущую позицию соответствия внутри этой строки.

Блок кода вводит новую область с точки зрения лексического
объявления переменных, но B<не> с точки зрения C<локального> и
аналогичного локализованного поведения. Чуть позже блоки кода в том же
шаблоне будет по-прежнему видеть значения, которые были локализованы в предыдущих блоках.
Эти накопленные локализации отменяются либо в конце
успешного поиска, или, если утверждение возвратилось (assertion is backtracked) (сравните
L<"Backtracking">). Например,

  $_ = 'a' x 8;
  m<
     (?{ $cnt = 0 })               # Инициализация $cnt.
     (
       a
       (?{
           local $cnt = $cnt + 1;  # Обновляем $cnt,
                                   # обратная ссылка безопасна (backtracking-safe).
       })
     )*
     aaaa
     (?{ $res = $cnt })            # При удачном поиске копирование в
                                   # не-локализованную локацию.
   >x;

первоначально увеличит C<$cnt> до 8; затем во время отступает, его
значение будет развернуто обратно до 4, это значение назначается C <$res>.
В конце выполнения регекса $cnt будет уменьшено обратно в свое первоначальное
значение 0.

Это утверждение может использоваться как условие в

    (?(condition)yes-pattern|no-pattern)

свиче (переключателе). Если I<не> использовать таким образом, то результат выполнения C<кода>
помещается в специальную переменную C<$^R>. Это происходит сразу же, так только
C<$^R> может быть использован с другими  C<(?{ code })> утверждениями внутри того же самого
регулярного выражения.

Присваивание С<$^R> выше правильно локализовано, так, что старое
значение C<$^R> восстанавливается, если утверждение возвратилось при поиске; сравните L <"Поиск с возвратом">.

Обратите внимание, что специальная переменная C<$^N> особенно полезна с блоками кода для записи результатов подсовпадений в переменные без необходимости
 отслеживать количество вложенных скобок. Например:

  $_ = "The brown fox jumps over the lazy dog";
  /the (\S+)(?{ $color = $^N }) (\S+)(?{ $animal = $^N })/i;
  print "color = $color, animal = $animal\n";


=item C<(??{ code })>
X<(??{})>
X<regex, postponed> X<regexp, postponed> X<regular expression, postponed>

B<ПРЕДУПРЕЖДЕНИЕ>: Эта функция расширенных регулярных выражений считается
экспериментальной и может быть изменена без предварительного уведомления. Выполняемый код
имеет побочные эффекты и он может не выполняться одинаково от версии к версии
из-за эффекта будущих оптимизаций в регекс движке.

Это «отложенное» регулярное выражение. Оно ведет себя I<точно>
так же, как и C<(?{код})> , как описано выше, за исключением того, что
 возвращаемое значение не присваиваются C<$^R>, а рассматривается как
шаблон, компилируется, если он является строкой (или используется как есть, если это qr / / объект),
затем ищется соответствие, как если бы оно был вставлено вместо этой конструкции.

В ходе сопоставления этого вложенного шаблона, он имеет свой собственный набор
захваченных скобок (или захватов дальше), которые являются действительными во время подпоиска (промежуточного поиска), но удаляются, как только управление возвращается в основной шаблон. Например, следующий поиск,
с внутренним шаблоном захвата "B" и находящий "BB", пока внешний
шаблон захватывает "A";

    my $inner = '(.)\1';
    "ABBA" =~ /^(.)(??{ $inner })\1/;
    print $1; # prints "A";

Обратите внимание, что это означает, что нет никакого способа, чтобы внутренний шаблон ссылался на
группу захвата, определенную вне. (Сам блок кода можно использовать C<$1>,
и т.д., для ссылки на группу захвата включенного шаблона.) Таким образом, хотя

    ('a' x 100)=~/(??{'(.)' x 100})/

I<найдет> он I<не> установит $1 при выходе.

Следующий шаблон найдет группу в круглых скобках:

 $re = qr{
            \(
            (?:
               (?> [^()]+ )  # Не-парные без поиска с возвратом
             |
               (??{ $re })   # Группы с соответствующими парными скобками
            )*
            \)
         }x;

Смотрите также
L<C<(?I<PARNO>)>|/(?PARNO) (?-PARNO) (?+PARNO) (?R) (?0)>
для другого, более эффективного способа выполнения этой задачи.

Выполнение отложенного регулярного выражения 50 раз без получения какой-либо
входной строки приведет к фатальной ошибке. Максимальная глубина компилируется
в perl поэтому, чтобы  изменить её требуется кастомный билд(custom build).

=item C<(?I<PARNO>)> C<(?-I<PARNO>)> C<(?+I<PARNO>)> C<(?R)> C<(?0)>
X<(?PARNO)> X<(?1)> X<(?R)> X<(?0)> X<(?-1)> X<(?+1)> X<(?-PARNO)> X<(?+PARNO)>
X<regex, recursive> X<regexp, recursive> X<regular expression, recursive>
X<regex, relative recursion>

Аналогично работает  C<(??{ code })> за исключением того, что он не предполагает выполнение любого
кода или потенциальной компиляции строки возвращенного шаблона; вместо этого он представляет
часть текущего шаблона, содержащийся в указанной группе захвата
как независимый шаблон, который должен совпадать с текущей позиции.
Группы захвата, содержащиеся в шаблоне, будут иметь значение, как это определено
во внешней рекурсии.

I<PARNO> является последовательность цифр (не начинающихся с нуля), значение которого отражает
число пар группы захвата для рекурсии. C<(?R)> рекурсивно проходит по
по шаблону с самого начала. C<(?0)> -это альтернативный синтаксис для
C<(?R)>. Если I<PARNO> предшествует плюс или минус, то можно предположить,
чтобы быть относительным, с отрицательными числами указывает предыдущие группы захвата
, а знак плюс группы после. Таким образом  C<(?-1)>  относится к наиболее недавно
объявленной группе и C<(?+1)> указывает следующую объявленную группу.
Обратите внимание, что подсчет относительной рекурсии отличается от
относительных обратных ссылок, в том, что в рекурсию B<включаются> не закрытые группы.

Следующий шаблон ищет функцию foo(), которая может содержать
сбалансированные скобки в качестве аргумента.

  $re = qr{ (                   # парная группа 1 (полная функция)
              foo
              (                 # парная группа 2 (пары)
                \(
                  (             # парная группа 3 (содержимое парных скобок)
                  (?:
                   (?> [^()]+ ) # Не парные без поиска с возвратом
                  |
                   (?2)         # Рекурсия на начало 2-й парной группы
                  )*
                  )
                \)
              )
            )
          }x;

Если шаблон был использован следующим образом

    'foo(bar(baz)+baz(bop))'=~/$re/
        and print "\$1 = $1\n",
                  "\$2 = $2\n",
                  "\$3 = $3\n";

результаты должны быть следующие:

    $1 = foo(bar(baz)+baz(bop))
    $2 = (bar(baz)+baz(bop))
    $3 = bar(baz)+baz(bop)

Если соответствующая группа захвата не определена , то 
будет фатальная ошибка. Рекурсии глубже, чем 50 без добавления на вход новой 
строки приведет также к фатальной ошибке. Максимальная глубина компилируется
в perl, поэтому для его изменения его требуется сделать кастомный билд (requires a custom build).

Ниже показано, как с помощью отрицательной индексации 
облегчить внедрение рекурсивных структур внутри конструкции C<qr//>
для дальнейшего использования:

    my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
    if (/foo $parens \s+ \+ \s+ bar $parens/x) {
       # сделать что-то здесь...
    }

B<Примечание>, что этот шаблон не ведёт себя так же, как эквивалент в
PCRE или Python такой же формы. В Perl можно делать поиск с возвратом в рекурсируемой
 группе, в PCRE и Python рекурсия в группе рассматривается как атомарная.
 Кроме того модификаторы разрешаются во время компиляции, так что такие конструкции 
как (?i:(?1)) или (?:(?i)(?1)) не влияют на то, как вложенный шаблон будет
обрабатываться.

=item C<(?&NAME)>
X<(?&NAME)>

Рекурсия для именованных шаблонов. Идентичен  C<(?I<PARNO>)>  за исключением того, что
на скобки для рекурсии указывает имя. Если несколько скобок
имеют то же имя, то она рекурсивно берет самую левую.

Возникнет сообщение об ошибке, если будет ссылка на имя, которое не объявлено где-то в
шаблоне.

B<ПРИМЕЧАНИЕ:> для того, чтобы облегчить жизнь программистов с опытом работы
с Python или движком регексов PCRE, шаблон C<< (?P>NAME) >>
может быть использован вместо  C<< (?&NAME) >>.

=item C<(?(condition)yes-pattern|no-pattern)>
X<(?()>

=item C<(?(condition)yes-pattern)>

Условное выражение. Найдет C<yes-pattern> если C<condition> дает
значение true, в противном случае ищет C<no-pattern> . Отсутствует шаблон 
по которому ищется всегда.

C <(condition)> должно быть одним из: 
1) целое число в
скобках (которое валидно, если соответствующая пара скобок найдена);
2) поиск впереди/поиск назад/выполнение утверждения нулевой ширины; 
3) имя в угловых скобках или одинарных кавычках (который валидно, если найдена группа
с заданным именем); или 
4) Специальный символ (R) (true когда выполнение внутри рекурсии или eval). 
Дополнительно после R могут быть числа, (которые будут true, когда выполняться рекурсия
внутри соответствующей группы) или C<&NAME>, в этом случае она будет
иметь значение true только при выполнении во время рекурсии именованной группы.

Вот краткое изложение возможных предикатов:

=over 4

=item (1) (2) ...

Проверяет, если что-то пронумерованные группы захвата что-то нашли.

=item (<NAME>) ('NAME')

Проверяет, если что группа с заданным именем что-то нашла.

=item (?=...) (?!...) (?<=...) (?<!...)

Проверяет, найден ли шаблон (или не найден, для вариантов с '!').

=item (?{ CODE })

Обрабатывает возвращаемое значение блока кода как условие.

=item (R)

Проверяет, что выражение выполняется внутри рекурсии.

=item (R1) (R2) ...

Проверяет, если выражение выполняется во время n-ной
 группы захвата. Эта проверка является эквивалентом следующему регексу

  if ((caller(0))[3] eq 'subname') { ... }

Другими словами он не проверяет полный стек рекурсии.

=item (R&NAME)

Аналогично C<(R1)>, этот предикат проверяет при выполнении
непосредственно внутри левой группы с заданным именем (это та же самая
логика используемая C<(?&NAME)> для устранения неоднозначности). Он не проверяет полный
стек, но только имя внутренней активной рекурсии.

=item (DEFINE)

В этом случае, да-шаблон выполняется не напрямую и нет никаких нет-шабонов.
Аналогично в духе C<(?{0})> но более эффективно.
Подробнее смотрите ниже.

=back

For example:

    m{ ( \( )?
       [^()]+
       (?(1) \) )
     }x

найдет часть с непарными скобками, возможно, включенные в парные скобки.

Особая форма - это предикат C<(DEFINE)> , который никогда не выполняет своих
yes-шаблонов непосредственно и не разрешает no-шаблоны. Это позволяет
определить подмаски, которые будут выполняться только механизмом рекурсии.
Таким образом, можно определить набор регулярных выражений, которые могут быть
 использованы в любом шаблоне, который вы выберете.

Рекомендуется, что для данного использования вы определяете блок DEFINE в
конце шаблона, и что вы задаете имена любым подшаблонам, определенным внутри него.

Кроме того, стоит отметить, что шаблоны определенные таким образом, вероятно, не могут
 быть эффективными, так как оптимизатор их обрабатывающий не достаточно умный.

Вот пример, как это может быть использовано:

  /(?<NAME>(?&NAME_PAT))(?<ADDR>(?&ADDRESS_PAT))
   (?(DEFINE)
     (?<NAME_PAT>....)
     (?<ADRESS_PAT>....)
   )/x

Обратите внимание, что группы захвата внутри  соответствующей рекурсии не доступны
после возврата из нее, так как для этого нужен дополнительный слой из группы захвата. 
Таким образом  C<$+{NAME_PAT}> не будет определяться, хотя
C<$+{NAME}> будет.

Наконец имейте в виду, что подшаблоны созданные внутри блока DEFINE
считают абсолютное и относительное число захватов, таким образом:

    my @captures = "a" =~ /(.)                  # Первый захват
                           (?(DEFINE)
                               (?<EXAMPLE> 1 )  # Второй захват
                           )/x;
    say scalar @captures;

Будет выводить 2, не 1. Это особенно важно, если вы намерены
компилировать регулярное выражение с помощью  C<qr//>
 и позднее интерполировать их в другой шаблон.

=item C<< (?>pattern) >>
X<backtrack> X<backtracking> X<atomic> X<possessive>

"Независимое" подвыражение, которой соответствует подстрока
 являющаяся I<автономным> (I<standalone>) 
C<шаблоном> , который найдется, если есть якорь на данной позиции,
 и он найдет I<ничего другого, кроме этой строки>.
Это конструкция полезна для оптимизации в противном случае были бы
 "вечные" поиски, потому что он не будет делать поиск с возвратом (см. L<"Backtracking">).
Он также может быть полезным в местах, где "захватить все можно и не
дать что-нибудь обратно" семантической желательно.

Например: C<< ^(?>a*)ab >> никогда не будет совпадать, тогда как C<< (?>a*) >>
(якорь в начале строки, как указано выше) будет соответствовать I<всем>
символам C<a> в начале строки, оставляя не C <a>для
поиска C<ab>. В противоположность этому C<a*ab> будет соответствовать тому же, что и C<a+b>,
поскольку поиск подгруппы C<a*> находится под влиянием следующей
группы C<ab>(см. L<"Backtracking">). В частности, C<a*> внутри
C<a*ab> будет соответствовать меньше символов, чем автономное C<a*>, так как
 оно делает хвостовой поиск.

C<< (?>pattern) >> не отключает поиск в возвратом всего один раз, пока не найдет. 
Еще возможен поиск с возвратом, проходящий мимо конструкции, но не
входящий в неё. Так что C<< ((?>a*)|(?>b*))ar >> будет по-прежнему соответствовать  "bar".

Эффект, аналогичный  C<< (?>pattern) >> может быть достигнут путем написания
C<(?=(pattern))\g{-1}>. Это соответствует той же подстроке, как автономная
C<a+> и следующий C <\g{-1}> ест совпавшие строки; он поэтому
делает утверждение нулевой длины в аналогичное C<< (?>...) >>.
(Разница между этих двумя конструкциями является тем, что во второй
используется группа захвата (записи), таким образом смещаются порядковые числа обратных ссылок
в остальной части регулярного выражения.)

Рассмотрим этот шаблон:

    m{ \(
          (
            [^()]+           # x+
          |
            \( [^()]* \)
          )+
       \)
     }x

Он будет эффективно соответствовать непустой группе с соответствующими скобками
до двух уровней или меньше. Однако, если нет такой группы, он
практически навсегда возьмет длинную строку. Это потому, что
так много различных способов разбить длинную строку на несколько
подстрок. Это то, что делает C<(.+)+> и C<(.+)+>  подобен
подшаблону выше шаблона. Рассмотрим, как шаблон
выше обнаруживает не нахождение C<((()aaaaaaaaaaaaaaaaaa> в несколько
секунд, но каждая дополнительная буква удваивает это время. Это
экспоненциальное повышение затрат сделает так, что ваша программа зависнет.
 Однако крошечные изменения в этот шаблоне

    m{ \(
          (
            (?> [^()]+ )        # изменим x+ выше на (?> x+ )
          |
            \( [^()]* \)
          )+
       \)
     }x

которая использует  C<< (?>...) >> находит точно,когда один выше делает (проверка
этого самостоятельно является хорошим упражнением), но заканчивается в четвертом
времени при использовании подобной строки с 1000000 C<a>s. Будьте осторожны,
однако, что, когда за этой конструкцией следует умножитель (квантификатор),
то он в настоящее время вызывает предупреждение под прагмой
C<use warnings> или ключа B<-w>, который говорит, что
C<"много раз найдены null строки в регексе"> (C<"matches null string many times in regex">).

На простых группах, таких, как шаблон C<< (?> [^()]+ ) >>, сопоставимый
эффект может быть достигнут путем негативного поиска вперед, как в C<[^()]+ (?! [^()] )>.
Это было только в 4 раза медленнее на строке с 1000000 C<a>s.

Сема́нтика (от др.-греч. σημαντικός — обозначающий) "Возьми все, что можешь и ничего не отдавать обратно"
 желательна во многих ситуациях, когда на первый взгляд простой  C<()*> выглядит как
правильное решение. Предположим, что мы анализировали текст с комментариями с разделителями
от C<#> за которыми следуют некоторые необязательные (горизонтальные) пробелы. В отличие от
его внешнего вида, C<#[ \t]*> I<Это не>  правильное подвыражение для поиска
разделителей комментариев, потому что она может "отказаться" от некоторых пробелов если
остальная часть шаблона совпадет. Правильный ответ на это - ни один из них:

    (?>#[ \t]*)
    #[ \t]*(?![ \t])

Например чтобы захватить не-пустые комментарии в $1, следует использовать что-либо
одно из этого:

    / (?> \# [ \t]* ) (        .+ ) /x;
    /     \# [ \t]*   ( [^ \t] .* ) /x;

От того, что вы выбираете, зависит, какие из этих выражений лучше отражают
выше спецификации комментариев.

В некоторой литературе эта конструкция называется "атомарным поиском" или
"притяжательным поиском"("possessive matching").

Притяжательные умножители эквивалентны поставленному элементу, к которому они применяются
внутри одной из этих конструкций. Применяются следующие эквиваленты:

    Форма с умножителями  Форма со скобками
    ---------------     ---------------
    PAT*+               (?>PAT*)
    PAT++               (?>PAT+)
    PAT?+               (?>PAT?)
    PAT{min,max}+       (?>PAT{min,max})

=item C<(?[ ])>

See L<perlrecharclass/Расширенные классы символов в квадратных скобках>.

=back

=head2 Специальные глаголы для управления поиска с возвратом (Special Backtracking Control Verbs)

B<ПРЕДУПРЕЖДЕНИЕ:> эти шаблоны являются экспериментальными и могут быть изменены или
удалены в будущей версии Perl. Их использование в продуктивном коде следует
специально отметить, чтобы избежать проблем при обновлении.

Эти специальные шаблоны, как правило, в форме C<(*VERB:ARG)>. Иногда
аргумент ARG является необязательным; в некоторых случаях это
запрещено.

Любой шаблон, содержащий специальный глагол возврата, который позволяет аргументу
иметь специальное поведение, когда выполнен он устанавливает в текущем пакете
C<$REGERROR> и C<$REGMARK> переменные. При этом применяются следующие
правила:

В случае неудачи, переменной C<$REGERROR> будет присвоено значение ARG
глагольного шаблона, если глагол принимал участие в этом поиске. Если
 значение ARG шаблона было опущено, то C<$REGERROR> будет присвоено 
имя последнего исполненного шаблона C<(*MARK:NAME)> , или в значение TRUE, если такого не было.
Кроме того, переменная C<$REGMARK> будет установлена в FALSE.

В случае успешного поиска, переменная C<$REGERROR> будет установлена в FALSE, а
переменной C<$REGMARK> будет присвоено имя последнего
исполненного шаблона C<(*MARK:NAME)>. Смотрите объяснение для
глагола C<(*MARK:NAME)> ниже.

B<ПРИМЕЧАНИЕ:> C<$REGERROR> и С<$REGMARK> не являются магическими переменными такими, как C<$1>
и большинство других переменных, связанных с регексами. Они не являются локальными для области, ни
ReadOnly, но вместо этого они аналогичны летучим переменным пакета C<$AUTOLOAD>.
Используйте C<local> для локализации изменений в их конкретной области при необходимости.

Если шаблон не содержит специального глагола для поиска с возвратом, который позволяет
аргумент, то C<$REGERROR> и C<$REGMARK> не затрагиваются вообще.

=over 3

=item Глаголы, которые принимают аргумент

=over 4

=item C<(*PRUNE)> C<(*PRUNE:NAME)>
X<(*PRUNE)> X<(*PRUNE:NAME)>

Этот шаблон нулевой ширины удаляет дерево с возвратом  в текущей точке
когда возврат был неудачным. Рассмотрим шаблон C<A (*PRUNE) B>,
где A и B являются сложными шаблонами. Пока не достигается глагола <(*PRUNE)> ,
A может возвращаться назад, если это нужно для сопоставления. После того, как оно будет достигнуто, 
поиск продолжается к B, который также может возвращаться в случае необходимости; Однако, если B
не найдено, то без дальнейших возвратов мы займет место и поиск по шаблону
будет неудачным прямо в текущей начальной позиции.

В следующем примере подсчитывается все возможные соответствия строк в
шаблоне (без фактического сопоставления любой из них).

    'aaab' =~ /a+b?(?{print "$&\n"; $count++})(*FAIL)/;
    print "Count=$count\n";

что производит:

    aaab
    aaa
    aa
    a
    aab
    aa
    a
    ab
    a
    Count=9

Если мы добавим C<(*PRUNE)>  перед count следующим образом

    'aaab' =~ /a+b?(*PRUNE)(?{print "$&\n"; $count++})(*FAIL)/;
    print "Count=$count\n";

мы предотвратили поиск с возвратом и нашли число самой длинной найденной строки
в каждой соответствующей отправной точке следующим образом:

    aaab
    aab
    ab
    Count=3

Любое число утверждений C<(*PRUNE)>  может использоваться в шаблоне.

Смотрите также  C<< (?>pattern) >> и притяжательные квантификаторы для других способов
управления возвратом. В некоторых случаях использование C<(*PRUNE)> 
может быть заменено на C<< (?>pattern) >>  без функциональной разницы; однако,
C<(*PRUNE)>  может использоваться для обработки случаев, которые не могут быть выражены с помощью
одного C<< (?>pattern) >>

=item C<(*SKIP)> C<(*SKIP:NAME)>
X<(*SKIP)>

Этот шаблон нулевой ширины подобен C<(*PRUNE)>, за исключением случая 
неудачного поиска, это также означает, что любой текст, который стоит перед шаблоном
C<(*SKIP)> не может быть частью, I<любого> матча текущего
 шаблона. Это фактически означает, что обработчик регулярных выражений "пропускает" вперед
на эту позицию в случае неудачного поиска и пытается снова продолжить поиск(предполагая, что
имеется достаточно места для соответствия).

Имя шаблона  C<(*SKIP:NAME)> имеет особое значение. Если
C<(*MARK:NAME)> обнаружен при сопоставлении, то это эту позицию
используют в качестве "точки пропуска». Если не было обнаружено  <(*MARK)>,
то оператор C<(*SKIP)>  не имеет никакого эффекта. При использовании
без имени "точки пропуска" там, где была точка поиска, когда выполнялся
 (*SKIP)  шаблон.

Сравните следующие примеры в C<(*PRUNE)>;  обратите внимание строки, что
строка в два раза длиннее:

 'aaabaaab' =~ /a+b?(*SKIP)(?{print "$&\n"; $count++})(*FAIL)/;
 print "Count=$count\n";

выведет

    aaab
    aaab
    Count=2

После того, как "aaab" в начале строки найден и выполнен C<(*SKIP)>
, следующий отправной точкой будет место, где выполнен C<(*SKIP)>.

=item C<(*MARK:NAME)> C<(*:NAME)>
X<(*MARK)> X<(*MARK:NAME)> X<(*:NAME)>

Это нулевой ширины шаблон может быть использован, чтобы отметить точку, достигнутое в строке
когда определенная часть шаблона успешно найдена. Этому
знак может быть дано имя. Через С<(* SKIP)> шаблон будет пропускать
вперед к этой точке, если он отступил в случае неудачи. Любое количество
шаблонов C<(*MARK)> разрешено, а ИМЯ может быть продублировано.

Помимо взаимодействия с шаблоном C<(*SKIP)>, C<(*MARK:NAME)>
может использоваться как "метка" разветвления шаблона, так что после сопоставления,
программа может определить, какие ветви шаблона были вовлечены в
поиск (матч).

Если совпадение успешно, переменной C<$REGMARK> будет присвоено
имя последнего выполненного C<(*MARK:NAME)> , который участвовал
в поиске.

Это может использоваться для определения, какая ветвь шаблона сработала
без использования отдельной группы для каждой ветви, которые в свою очередь
может привести к улучшению производительности, так как perl не может оптимизировать
C</(?:(x)|(y)|(z))/> также эффективно, как что-то типа
C</(?:x(*MARK:x)|y(*MARK:y)|z(*MARK:z))/>.

Когда поиск не удался, и пока другой глагол был вовлечен в
 ошибочный поиск и предоставил свое собственное имя для использования, 
переменной  C<$REGERROR> будет присвоено имя последнего выполненного
C<(*MARK:NAME)>.

См. L</(*SKIP)> для более подробной информации.

В качестве быстрого имени (шортката) C<(*MARK:NAME)> может быть написан, как C<(*:NAME)>.

=item C<(*THEN)> C<(*THEN:NAME)>

Это похоже на оператор C<::> "вырезать группу" в Perl 6. Также, как и
C<(*PRUNE)>, эта команда всегда совпадает и когда поиск с возвратом неудачен,
он вызывает обработчик регексов, чтобы попробовать следующее чередование во
внутренней, включающей группе (захвата или иным образом), которая имеет альтернативы.
Две ветви C<(?(condition)yes-pattern|no-pattern)> не
считают альтернативу так, как это делает C<(*THEN)>

Его название происходит от наблюдения, что эта операция в сочетании с
оператором чередования (C<|>) может использоваться для создания по сути
 шаблоно-блоков если/то/иначе:

  ( COND (*THEN) FOO | COND2 (*THEN) BAR | COND3 (*THEN) BAZ )

Обратите внимание, что если используется этот оператор не внутри чередование, то
он действует так же, как оператор C<(*PRUNE)>.

  / A (*PRUNE) B /

Это то же самое, что и

  / A (*THEN) B /

но

  / ( A (*THEN) B | C ) /

не тоже самое, что и

  / ( A (*PRUNE) B | C ) /

так как после нахождения A, но при неудачном поиске B глагол C<(*THEN)>
 сделает возврат и попробует C; но глагол C<(*PRUNE)> просто закончится неудачей.

=back

=item Глаголы без аргументов

=over 4

=item C<(*COMMIT)>
X<(*COMMIT)>

Это "шаблон фиксации" из Perl 6  C<< <commit> >> или C<:::>. Это
нулевой ширины шаблон подобен C<(*SKIP)>, за исключением случаев, когда поиск с возвратом
 будет неудачным он вызывает неудачу не сразу. Никаких дальнейших попыток
чтобы найти правильны матч, продвигая указатель в начало будет происходить снова.
Например,

 'aaabaaab' =~ /a+b?(*COMMIT)(?{print "$&\n"; $count++})(*FAIL)/;
 print "Count=$count\n";

выведет

    aaab
    Count=1

Другими словами после того как был введен C<(*COMMIT)> и, если шаблон
не совпадает, то движок регексов не будет попробовать любые дополнительные поиск на
остальной части строки.

=item C<(*FAIL)> C<(*F)>
X<(*FAIL)> X<(*F)>

Этот шаблон соответствует ничему и всегда терпит неудачу. Он может использоваться для принудительного
движка с поиском с возвратом. Это эквивалентно C<(?!)>, но легче читать. 
Фактически, C<(?!)> получает оптимизированное C<(*FAIL)> внутренне.

Это вероятно полезно только при сочетании с C<(?{})> или C<(??{})>.

=item C<(*ACCEPT)>
X<(*ACCEPT)>

B <ПРЕДУПРЕЖДЕНИЕ:> эта функция является весьма экспериментальной. Не рекомендуется
для кода в продакшене.

Этот шаблон ничего не ищет и возникает в конце успешного поиска в точке, в которой
шаблон C<(*ACCEPT)> был обнаружена, независимо от того, есть ли на самом деле больше искать
 в строке. Когда внутри вложенный шаблон, например рекурсии, или в подшаблоне 
динамически генерируемые данные через  C<(??{})>, только самый внутренний 
шаблон завершается немедленно.

Если C<(*ACCEPT)> внутри группы захвата тогда группа помечает
 конец в точке, в которой был обнаружен C<(*ACCEPT)>.
К примеру:

  'AB' =~ /(A (A|B(*ACCEPT)|C) D)(E)/x;

будет найден и C<$1> будет C<AB> и C<$2> будет C<B>, а C<$3> не будет
установлен. Если другая ветка во внутренних скобках будет найдена, например, 
как строка "ACDE", тогда C<D> и C<E> будут найдены также.

=back

=back

=head2 Поиск с возвратом (Backtracking)
X<backtrack> X<backtracking>

Примечание: В этом разделе абстрактно представлено приблизительное 
 поведение регулярных выражений. Для просмотра более строгого (и сложного)
 видения правил участия в выборе найденного среди возможных альтернатив,
смотрите L<Сочетая частей RE>.

Фундаментальная возможностью поиска регулярными выражениями
включает в себя понятие под названием I<Поиск с возвратом> (I<backtracking>), который используется в настоящее время (при необходимости)
 всеми регулярными выражениями с не притяжательными повторителями, а именно C<*>, C<*?>, C<+>,
C<+?>, C<{n,m}>, и C<{n,m}?>. Часто поиск с возвратом оптимизирован
внутренне, но общий принцип, изложенный здесь является допустимым.

Для поиска регулярным выражением I<всё> регулярное выражение должно
совпасть, а не только часть его. Так что, если начало шаблона, содержащего
повторитель успешно совпало способом, который вызывает позже части шаблона
 для неудачного поиска, поисковый движок возвращается и пересчитывает начальную часть
 - вот почему он называется поиском с возвратом.

Вот пример поиска с возвратом: скажем, вы хотите найти
слово после "foo" в строке "Food is on the foo table.":

    $_ = "Food is on the foo table.";
    if ( /\b(foo)\s+(\w+)/i ) {
        print "$2 следует за $1.\n";
    }

Когда поиск начинается, первая часть регулярного выражения (C<\b(foo)>)
 находит возможное возможное справа, в самом начале строки и загружает
$1 в "Foo". Однако, как только поисковый движок видит, что нет пробелов 
после "Foo", который он положил в $1, он понимает свою
ошибку и начинается новый поиск после знака, где он делал
предварительный поиск. На этот раз он идет вплоть до следующего вхождения
"foo". Полное регулярное выражение сопоставляется в этот раз, и вы получаете
ожидаемый результат "table следует за foo."

Иногда минимальный поиск может сильно помочь. Представьте, что вы хотели бы найти
все, что между "foo" и"bar". Изначально вы напишете что-то типа этого:

    $_ =  "The food is under the bar in the barn.";
    if ( /foo(.*)bar/ ) {
        print "got <$1>\n";
    }

Который, возможно, неожиданно дает:

  got <d is under the bar in the >

Это потому, что  C<.*> жадный, так что вы получите все, что между
I<первым> "foo" и I<последним> "bar". Здесь более эффективным
является использование минимального соответствия, чтобы убедиться, вы получите текст между "foo"
и первым "bar" после этого.

    if ( /foo(.*?)bar/ ) { print "got <$1>\n" }
  got <d is under the >

Вот еще один пример. Допустим, вы хотите найти число в конце
строки и вы также хотите сохранить предыдущую часть.
То вы напишете следующее:

    $_ = "I have 2 numbers: 53147";
    if ( /(.*)(\d*)/ ) {                                # Неправильно!
        print "Beginning is <$1>, number is <$2>.\n";
    }

Это не будет работать совсем, потому что C<.*> жадный и съест вверх
всю строку. Так как C<\d*> может соответствовать пустой строке, то полное
регулярное выражение будет успешно найдено.

    Beginning is <I have 2 numbers: 53147>, number is <>.

Вот некоторые варианты, большинство из которых не работают:

    $_ = "I have 2 numbers: 53147";
    @pats = qw{
        (.*)(\d*)
        (.*)(\d+)
        (.*?)(\d*)
        (.*?)(\d+)
        (.*)(\d+)$
        (.*?)(\d+)$
        (.*)\b(\d+)$
        (.*\D)(\d+)$
    };

    for $pat (@pats) {
        printf "%-12s ", $pat;
        if ( /$pat/ ) {
            print "<$1> <$2>\n";
        } else {
            print "FAIL\n";
        }
    }

Это напечатает:

    (.*)(\d*)    <I have 2 numbers: 53147> <>
    (.*)(\d+)    <I have 2 numbers: 5314> <7>
    (.*?)(\d*)   <> <>
    (.*?)(\d+)   <I have > <2>
    (.*)(\d+)$   <I have 2 numbers: 5314> <7>
    (.*?)(\d+)$  <I have 2 numbers: > <53147>
    (.*)\b(\d+)$ <I have 2 numbers: > <53147>
    (.*\D)(\d+)$ <I have 2 numbers: > <53147>

Как вы видите, это может быть немного сложнее. Важно понимать, что
регулярное выражение-это просто набор утверждений, которые определяют
успех. Может быть 0, 1 или несколько различных способов определений,
 который могут быть успешны против конкретной строки. И если есть
несколько способов, которыми можно добиться успеха, то вам нужно понять поиск с возвратом, 
 чтобы узнать, насколько разнообразного успеха вы добьетесь.

При использовании утверждений осмотра вперед утвердительного или отрицательного, это может получиться даже
сложнее. Представьте, что вы хотели бы найти последовательность не-цифр, за которыми не следует "123". 
Вы можете попробовать написать так

    $_ = "ABC123";
    if ( /^\D*(?!123)/ ) {                # Неправильно!
        print "Yup, no 123 in $_\n";
    }

Но это не будет найдено; по крайней мере не так, как вы надеетесь. Здесь 
утверждается, что в строке нет никаких 123. Вот более четкая картина о том,
почему этот шаблон совпадает, вопреки всеобщим ожиданиям:

    $x = 'ABC123';
    $y = 'ABC445';

    print "1: got $1\n" if $x =~ /^(ABC)(?!123)/;
    print "2: got $1\n" if $y =~ /^(ABC)(?!123)/;

    print "3: got $1\n" if $x =~ /^(\D*)(?!123)/;
    print "4: got $1\n" if $y =~ /^(\D*)(?!123)/;

Это напечатает

    2: got ABC
    3: got AB
    4: got ABC

Вы могли рассчитывать, что 3 тест будет провален, потому что он кажется более
общим назначением теста 1. Важное различие между
ними является то, что тест 3 содержит квантификатор (C<\D*>) и поэтому он может использовать
поиск с возвратом, тогда как тест 1 не будет. Что происходит, когда
 вы спросили "это правда, что в начале $x, после 0 или больше
не цифр, у вас есть что-то не 123?" Если совпадений шаблона
пусть C<\D*> расширяется до "ABC", это привело бы к тому, что весь шаблон
 был бы провальным.

Поисковый движок изначально будет искать шаблон C<\D*> в "ABC". Затем он 
попробует найти C<(?!123)> в "123", что не удастся. А потому, что
повторитель (C<\D*>) был использован в регулярном выражении,
поисковый движок может искать с возвратом и повторить поиск по-разному
в надежде на полное соответствие регулярного выражения.

Шаблон действительно, I<действительно> хочет добиться успеха, поэтому он использует
стандартный шаблон "возвратись-и-повтори" и позволяет C<\D*> расширится до просто "AB" в это
время. Теперь это действительно что-то после "AB" это не
"123". Это "C123", которого достаточно.

Мы можем иметь дело с этим с помощью утверждения и отрицания.
Мы будем говорить, что за первой частью в $1 должна идти цифра
 что-то не "123". Помните, что осмотр-вперед является выражением
нулевой ширины -- они только так выглядят, но не потребляют никакой строки
 во время поиска. Так что переписывания таким образом производит то, что 
можно было бы ожидать; то есть 5 случай неуспешен, а 6 случай успешен:

    print "5: got $1\n" if $x =~ /^(\D*)(?=\d)(?!123)/;
    print "6: got $1\n" if $y =~ /^(\D*)(?=\d)(?!123)/;

    6: got ABC

Другими словами,работают два утверждения нулевой ширины рядом друг с другом
они объединяются вместе, так же, как и любые встроенные утверждения:C</^$/>
соответствует только если вы в начале строки и в конце
строки одновременно. Более глубокая правда в том, что соседство в
регулярные выражения всегда означает И, за исключением случаев, когда вы пишете явно ИЛИ
, используя вертикальную черту. C</ab/> означает поиск "a" И (потом) поиск "b",
хотя попытки поиска сделаны на разных позициях, потому что "a"
это не утверждение нулевой ширины, а утверждение в ширину один символ.

B<ПРЕДУПРЕЖДЕНИЕ>: особенно сложные регулярные выражения могут занимать
экспоненциальное время для их решения из-за огромного количества возможных
способов, которыми они могут использовать поиск с возвратом для поиска. Например, без
внутренней оптимизации, сделанной обработчиком регулярных выражений, это будет
 занимать много времени для работы:

    'aaaaaaaaaaaa' =~ /((a{0,5}){0,5})*[c]/

И если вы использовали C<*> на внутренние группы вместо их ограничения
с 0 до 5 раз, то он будет считать вечно --или до тех пор, пока вы не достигнете
переполнения стека. Кроме того эти внутренние оптимизации являются не
всегда применимыми. Например, если вы поставили C<{0,5}> вместо C<*>
на внешней группе, не применяется  текущая оптимизация и
поиск занимает много времени для завершения.

Мощный инструмент для оптимизации таких зверских выражений является то, что известно как
"Независимая группа", которая не использует поиск с возвратом (см. L</C<< (?>pattern) >>>).
Обратите внимание, что утверждения нулевой длины такие как осмотр-вперед/осмотр-назад  не будет
делать поиск с возвратом, чтобы найти хвостовой поиск, так как они находятся в "логическом" контексте: 
только то место, где они найдутся считается соответствующим. В качестве примера
где побочные эффекты осмотра-вперед I<могут> иметь влияние на последующий поиск, см L</C<< (?>pattern) >>>.

=head2 8 версия регулярных выражений
X<regular expression, version 8> X<regex, version 8> X<regexp, version 8>

В случае, если вы не знакомы с "обычной" 8 версией регекс 
процедур, вот правила сопоставления шаблонов, не описанные выше.

Любой один символ соответствует самому себе, если это не I<метасимвол>, которые имеют
особое значение, описанное здесь или выше. Вы можете вызывать
символы, которые обычно являются метасимволами буквально, 
предваряя их  "\" (например, поиск "\." найдет ".",а не какой-либо другой
символ; "\\" найдет "\"). Этот механизм экранирования нужен также 
для символа, используемого в качестве разделителя шаблона.

Серия символов соответствует этой серии символов в целевой
строке, поэтому шаблон C <blurfl> будет соответствовать "blurfl" в целевой
строке.

Можно указать класс символов, заключив список символов
в C<[]>, который будет соответствовать любому символу из списка. Если
первый символ после  "["  "^",класс соответствует любому знаку, не
в списке. В списке символ "-" указывает на диапазон, 
так что C<a-z> представляет все символы между "a" и "z"
включительно. Если вы хотите, чтобы либо "-" либо "]" сами собой были членами
класса, поместите их в начале списка (возможно, после "^"), или
поставьте перед символами обратный слеш. "-" также воспринимается буквально, когда оно находится
в конце списка, непосредственно рядом с "]". (следующие выражения ниже указывают на класс из трех символов: C<[-az]>,
C<[az-]> и C<[a\-z]>. Все они отличаются от C<[a-z]>, который
указывает класс, содержащий двадцать шесть символов, даже на основе EBCDIC
набора символов.) Кроме того, если вы попытаетесь использовать символ
класса  C<\w>, C<\W>, C<\s>, C<\S>, C<\d>, или C<\D> как конечные точки
диапазона, то "-" понимается буквально.

Также, обратите внимание, что идея со всем диапазоном  довольно непереносима между
наборами символов -- и даже в пределах наборов символов она может привести к результатам, которые
 вы, вероятно, не ожидали. Здесь принцип заключается в том, чтобы использовать только диапазоны, 
начинающиеся и заканчивается либо в одном алфавите одинакового регистра  ([a-e],
[A-E]), или цифр ([0-9]). Все остальное является небезопасным. Если есть сомнения,
приведите набор символов в полном объеме.

Символы могут быть указаны с помощью синтаксиса метасимволов такого, какой
используется в C: "\n" найдет новую строку, "\t" - табулятор, "\r" - возврат каретки,
"\f" подача страницы на принтере (form feed), и т.д. В целом \I<nnn>, где I<nnn> является строкой
из трех восьмеричных цифр соответствует символу, чьи закодированное символьное значение
это  I<nnn>. Аналогично для \xI<nn>, где I<nn> являются шестнадцатеричными цифрами,
соответствует символу, чей порядковый номер это  I<nn>. Выражение \cI<x>
соответствует элементу управления control-I<x>. Наконец метасимвол "." 
соответствует любому знаку, кроме "\n" (если вы используете C</s>).

Можно указать ряд альтернатив для шаблона с помощью "|" для
 их разделения, так что C<fee|fie|foe> найдет любое из "fee", "fie",
или "foe" в целевой строке (как бы C<f(e|i|o)e>). 
Первый вариант включает в себя все, от последнего разделителя шаблона
("(", "(?:",  и т.д. или в начале шаблона) до первого  "|", и
последний вариант содержит все, что от последнего  "|" к следующему
закрывающему шаблон разделителю. Вот почему это обычная практика для включения
альтернативы в скобках: для минимизации путаницы о том, где у них
начало и конец.

Альтернативы применяются слева направо, так что, если первая
альтернатива найдена, то есть все выражение совпадает, это то, что
выбирается. Это означает, что альтернативы не обязательно жадные. Для
примера: при сопоставлении C<foo|foot> против "barefoot", только часть "foo"
 будет найдена, так как пытался первый вариант и он был успешно найден
 в строке целевого объекта. (Это может показаться не важным, но это
важно, когда вы захватываете совпадающий текст, используя скобки.)

Также помните, что "|" интерпретируется как литерал в квадратных скобках,
так что если вы пишете C<[fee|fie|foe]> вы действительно ищете совпадение C<[feio|]>.

Внутри шаблона вы можете определять подшаблоны для последующего использования
заключив их в скобки и вы можете обратиться к
I<n>ному подшаблону позже в шаблоне, используя метасимвол
\I<n> или \gI<n>. Подмаски нумеруются начиная слева направо
 по очереди открывающих скобок. Обратная ссылка совпадает независимо от
того найдется ли на самом деле соответствие подшаблону в  рассматриваемой строке, не от
правил для этого подшаблона. Таким образом будет  C<(0|0x)\d*\s\g1\d*>
 найдет "0x1234 0x4321", но не "0x1234 01234",потому что подшаблон
1 соответствует  "0x", даже несмотря на то, что  правило C<0|0x> потенциально может соответствовать
ведущему 0 во второй цифре.

=head2 Предупреждение на \1 вместо $1

Некоторые люди слишком привыкли писать такие вещи, как:

    $pattern =~ s/(\W)/\\\1/g;

Это старая привычка (для ссылок от \1 до \9) для RHS замены для избежания 
шокирующей для B<sed>фанатов, но это также грязная привычка попасть. Это потому, что в
PerlThink, правой стороне C<s///> представляет собой строку с двойными кавычками. C<\1> в
обычные двойных кавычках строка означает управления A. Для обычного Unix
значение C<\1> является хаком для C<s///>. Однако если вы получите привычку
сделать это, вы получить себе в беду, если вы затем добавите модификатор C</e>.

    s/(\d+)/ \1 + 1 /eg;            # приведет к предупреждению под флагом -w

Или, если вы попытаетесь сделать

    s/(\d+)/\1000/;

Вы не сможете устранить неоднозначность, сказав C<\{1}000>, в то время как вы можете исправить это только так
C<${1}000>. Не следует путать операции интерполяции
с операцией поиска обратной ссылки. Конечно они значат две
разные вещи на I<левой> стороне C<s///>.

=head2 Повторяющиеся шаблоны поиска подстроки нулевой длины

B<ПРЕДУПРЕЖДЕНИЕ>: трудный материал (и проза) будут впереди. Этот раздел необходимо переписать.

Регулярные выражения предоставляют лаконичный и мощный язык программирования. Как
 и многие другие инструменты власти власть приходит вместе со способностью
сеять хаос.

Общие злоупотребления этой властью проистекает из способность сделать бесконечные
циклы с помощью регулярных выражений, с чем-то настолько безобидным, как:

    'foo' =~ m{ ( o? )* }x;

C<o?> находит в начале C<'foo'> и с тех пор позиция
в строке не перемещается, поиск, C<o?> будет искать снова и снова
из-за квантификатора C<*> . Еще один распространенный способ создания аналогичного цикла
является циклирующий модификатор C<//g>:

    @matches = ( 'foo' =~ m{ o? }xg );

или

    print "match: <$&>\n" while 'foo' =~ m{ o? }xg;

или под циклом подразумевается split().

Однако многолетний опыт показал, что многие задачи программирования можно
значительно упростить с помощью повторяющихся подвыражений
, которым могут соответствовать подстроки нулевой длины. Вот простой пример того:

    @chars = split //, $string;           # // нет магии split()
    ($whitewashed = $string) =~ s/()/ /g; # закрытые скобки избегают магии s// /

Таким образом Perl позволяет такие конструкции, чтобы I<насильственно разорвать
бесконечный цикл>. Правила для этого различны для низко-уровневых
циклов предоставлены "жадные" повторители кванторы C<*+{}>, а  для более высокого уровня
 циклов такие модификаторы, как C</g>  или оператор split().

Циклы нижнего уровня являются I<прерываемыми>(то есть цикл является
сломанный) когда Perl обнаруживает, что повторяемое находит подстроку
нулевой длины. Таким образом

   m{ (?: NON_ZERO_LENGTH | ZERO_LENGTH )* }x;

производит эквивалентно

   m{ (?: NON_ZERO_LENGTH )* (?: ZERO_LENGTH )? }x;

Например, эта программа

   #!perl -l
   "aaaaab" =~ /
     (?:
        a                 # не равно нулю
        |                 # или
       (?{print "hello"}) # печатать hello всякий раз, когда эта
                          #    ветка выбирается
       (?=(b))            # утверждение нулевой длины
     )*  # любое число раз
    /x;
   print $&;
   print $1;

напечатает

   hello
   aaaaa
   b

Обратите внимание, что "hello" будет напечатан один раз, 
когда Perl увидит, что шестая итерация внешнего C<(?:)*> 
найдет строку нулевой длины,и он останавливает C<*>.

Внешний цикл сохраняет дополнительное состояния между итерациями:
 в зависимости о того является ли последний поиск нулевой длины. 
 Чтобы разорвать цикл, следующий поиск после совпадения нулевой 
 длины запрещается иметь нулевой длины.
Этот запрет взаимодействует с поиском с возвратом (см. L<"Поиск с возвратом">),
и поэтому I<второй лучший> поиск выбирается, если I<лучший> поиск
нулевой длины.

Например:

    $_ = 'bar';
    s/\w??/<$&>/g;

результаты в C<< <><b><><a><><r><> >>. В каждой позиции строки лучший
 поиск дает не-жадное C<??>, это совпадения нулевой длины и I<вторым лучший>
  поиском является то, что находится C<\w>. Таким образом, поиск нулевой длины
является альтернативой поиска односимвольной строки.

Аналогично, для повторного C<m/()/g> вторым лучшим поиском является поиск в позиции на
 одну ступень далее в строке.

Дополнительное состояние I<поиска нулевой длины> связано с
найденной строкой и сброса каждого назначения для pos().
Поиски нулевой длины в конце предыдущего поиска игнорируются
во время C<split>.

=head2 Сочетание кусков РЕГЕКСПОВ

Каждой из элементарных частей регулярного выражения, которые были описаны
ранее (например, C<ab> или C<\Z>) могут соответствовать более чем одной 
подстроки в данной позиции входной строки. Однако в типичных регулярных
выражениях эти элементарные части объединяются в более сложные
шаблоны, с помощью сочетания операторов C<ST>, C<S|T>, C<S*> и т.д.
(в этих примерах C<S> и C<T> - регулярные выражения).

Такие комбинации могут включать альтернативы, ведущих к проблеме выбора:
если мы ищем совпадение для регулярного выражения C<a|ab> в строке C<"abc">, чему оно будет соответствовать подстроке C<"a"> или C<"ab">? Один из способов описать какие подстроки на самом деле находятся является концепция Поиска с возвратом (см. L<"Поиск с возвратом">).
Однако это описание слишком низкого уровня и заставляет вас думать
с точки зрения конкретной реализации.

Другое Описание начинается с понятий "лучше"/"хуже". Все
подстроки, которые могут быть сопоставлены с заданным регулярным выражением могут быть отсортированы от "лучшего" совпадения до "худшего", и это "лучшее"
 сопоставление и будет выбрано. Это заменяет вопрос "что выбрали?"
на вопрос "какие сопоставления лучше, а какие хуже?».

Опять же для элементарных частей не существует такого вопроса, поскольку в большинстве случаев возможно только одно совпадение в заданной позиции. В этом разделе описывается понятие лучше/хуже для объединения операторов. В описании
ниже C<S> и C<T> - это регулярные выражения.

=over 4

=item C<ST>

Рассмотрим два возможных поиска, C<AB> и C<A'B'>, C<A> и C<A'>
 - это подстроки, которые могут быть найдены C<S>, C<B> и C<B'> подстроки
которые могут быть найдены C<T>.

Если C<A> является лучшим поиском для C<S>,чем C<A'>, то C<AB> будет лучшим
поиском, чем C<A'B'>.

Если C<A> и C<A'> совпадают: C<AB> - лучший поиск, чем C<AB'>, если
C<B> лучший поиск для C<T> чем C<B'>.

=item C<S|T>

Когда C<S> может найтись, это лучшее совпадение, чем когда может найтись только С<T>.

Последовательность двух поисков для C<S> является такой же и для C<S>. 
Аналогично для двух поисков для C<T>.

=item C<S{ЧИСЛО_ПОВТОРОВ}>

Найдет, как C<SSS...S> (повторяя столько раз сколько нужно).

=item C<S{min,max}>

Найдет C<S{max}|S{max-1}|...|S{min+1}|S{min}>.

=item C<S{min,max}?>

Найдет C<S{min}|S{min+1}|...|S{max-1}|S{max}>.

=item C<S?>, C<S*>, C<S+>

Тоже, что и  C<S{0,1}>, C<S{0,BIG_NUMBER}>, C<S{1,BIG_NUMBER}> соответственно.

=item C<S??>, C<S*?>, C<S+?>

Тоже, что и C<S{0,1}?>, C<S{0,BIG_NUMBER}?>, C<S{1,BIG_NUMBER}?> соответственно.

=item C<< (?>S) >>

Соответствует лучшему поиску для C<S> и только так.

=item C<(?=S)>, C<(?<=S)>

Только лучший поиск для C<S> рассматривается. (Это имеет значение только, если
C<S> имеет скобки, и где-то используются обратные ссылки где-то
еще в целом регулярном выражении.)

=item C<(?!S)>, C<(?<!S)>

Для этого оператора группирования нам не нужно описать порядок следования, так как
только поиск по не C<S> имеет важное значение.

=item C<(??{ EXPR })>, C<(?I<PARNO>)>

Порядок такой же, как для регулярного выражения, которым является
результат EXPR, или шаблон, содержащий группу захвата I<PARNO> (I<НОМЕРСКОБКИ>).

=item C<(?(condition)yes-pattern|no-pattern)>

Вызов C<да-шаблона> или C<нет-шаблона> 
уже определен своим совпадением. Последовательность (ordering) поиска
такая же, как и выбранные подвыражения.

=back

Рецепты выше описывают последовательность поиска I<в заданной позиции>.
Еще одно правило необходимо понять, как поиск определяется для
всего регулярного выражения: поиск на ранней позиции всегда лучше,
чем успешный поиск в поздней позиции.

=head2 Создание пользовательских движков РЕ (РЕГЕКСПОВ)

По состоянию на Perl 5.10.0 можно создать пользовательский движок регулярных выражений. Это не для слабонервных, так как они должны подключаться на уровне С.
 См.L<perlreapi> для получения более подробной информации.

В качестве альтернативы можно перегружать константы (см. C<overload>) предоставляют простой путь для расширения функциональности движка РЕ, 
заменяя один шаблон другим.

Предположим, что мы хотим, чтобы включить новую RE эскейп-последовательность C<\Y|>, которая ищет на границе между знаками пробела и непробельных
символов. Обратите внимание что C<(?=\S)(?<!\S)|(?!\S)(?<=\S)>
находит в точности на этих позициях, итак мы хотим иметь каждый C<\Y|> в месте  более сложной версии. Мы можем создать модуль C<customre>
 для того, чтобы делать это:

    package customre;
    use overload;

    sub import {
      shift;
      die "No argument to customre::import allowed" if @_;
      overload::constant 'qr' => \&convert;
    }

    sub invalid { die "/$_[0]/: invalid escape '\\$_[1]'"}

    # Мы должны также позаботиться о том, чтобы неэскейпить законную \\Y|
    # последовательность, поэтому присутствие '\\' в правилах преобразования.
    my %rules = ( '\\' => '\\\\',
                  'Y|' => qr/(?=\S)(?<!\S)|(?!\S)(?<=\S)/ );
    sub convert {
      my $re = shift;
      $re =~ s{
                \\ ( \\ | Y . )
              }
              { $rules{$1} or invalid($re,$1) }sgex;
      return $re;
    }

Теперь C<use customre> включает новую эсейп-последовательность
 в постоянных регулярных выражениях, то есть без какого-либо выполнения переменных интерполяции.
Как описано в L<overload>, это преобразование будет работать только над
литеральными (символьными) частями регулярных выражений. 
Для C<\Y|$re\Y|> переменная
часть этого регулярного выражения необходимо явно преобразовать
(но только если особое значение C<\Y|> должно быть включено внутри $re):

    use customre;
    $re = <>;
    chomp $re;
    $re = customre::convert $re;
    /\Y|$re\Y|/;

=head2 Поддержка PCRE/Python

По состоянию на Perl 5.10.0 Perl поддерживает несколько расширений Python/PCRE-специфичного синтаксиса регекс. 
В то время, как Perl программистов, рекомендуется использовать
Perl специфический синтаксис, также принимаются следующие:

=over 4

=item C<< (?PE<lt>NAMEE<gt>pattern) >>

Определение именованную группу. Эквивалент C<< (?<NAME>pattern) >>.

=item C<< (?P=NAME) >>

Обратная ссылка на именованную группу. Эквивалент C<< \g{NAME} >>.

=item C<< (?P>NAME) >>

Вызов подпрограммы как именованной группы. Эквивалент C<< (?&NAME) >>.

=back

=head1 ОШИБКИ (BUGS)

Многие конструкции регулярных выражений не работают на платформах EBCDIC.

Существует целый ряд проблем (issues) в отношении поиска без учета регистра
в правилах Юникода. Смотрите C<i> в статье L</Модификаторы> выше.

Этот документ варьируется от сложного для понимания до полностью
и совершенно непрозрачного. Блуждающие проза, изобилует жаргоном
трудно понимаемым в нескольких местах.

Этот документ нужно переписать, выделяя содержимое учебника
из ссылки на содержание.

=head1 СМОТРИТЕ ТАКЖЕ

L<perlrequick>.

L<perlretut>.

L<perlop/"Квотирование и Операторы заключения в кавычки">.

L<perlop/"Внутренние детали парсинга конструкций в кавычках">.

L<perlfaq6>.

L<perlfunc/pos>.

L<perllocale>.

L<perlebcdic>.

I<Mastering Regular Expressions> by Jeffrey Friedl, published
by O'Reilly and Associates.

=head1 ПЕРЕВОДЧИКИ
 
=over
 
=item * Николай Мишин C<< <mi@ya.ru> >>
 
=back
