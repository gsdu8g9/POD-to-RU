=encoding UTF-8

=head1 NAME/НАИМЕНОВАНИЕ

perlunitut - Учебник по Юникоду в Perl

=head1 ОПИСАНИЕ

Дни простой обработки строк закончились. Установлено, что
современные программы должны быть способны общаться смешанными акцентированными буквами и
такими вещами, как символы евро. Это означает, что программистам нужно новые привычки. 
Легко программировать Юникодо-совместимое программное обеспечение, но для этого требуется дисциплина, чтобы делать
 это правильно.

Существует много знаний о наборах символов и кодировках текста. Вероятно,
лучше всего провести целый день для их изучения, но основы могут быть изучены за минуты.

Это вообще-то не самые основы. Предполагается, что вы уже
знаете разницу между байтом и символом и понимаете (и принимаете!),
что существует много различных наборов символов и кодировок и, что ваша
Программа должна четко знать о них. Рекомендуется для чтения  
L<Абсолютный Минимум, который Каждый Разработчик Программного Обеспечения Обязательно Должен Знать о Unicode и Наборах Символов|http://local.joelonsoftware.com/wiki/%D0%90%D0%B1%D1%81%D0%BE%D0%BB%D1%8E%D1%82%D0%BD%D1%8B%D0%B9_%D0%9C%D0%B8%D0%BD%D0%B8%D0%BC%D1%83%D0%BC,_%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9_%D0%9A%D0%B0%D0%B6%D0%B4%D1%8B%D0%B9_%D0%A0%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA_%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE_%D0%9E%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F_%D0%9E%D0%B1%D1%8F%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE_%D0%94%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD_%D0%97%D0%BD%D0%B0%D1%82%D1%8C_%D0%BE_Unicode_%D0%B8_%D0%9D%D0%B0%D0%B1%D0%BE%D1%80%D0%B0%D1%85_%D0%A1%D0%B8%D0%BC%D0%B2%D0%BE%D0%BB%D0%BE%D0%B2>
 Джоэла Спольски , оригинал на английском
L<The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)|http://joelonsoftware.com/articles/Unicode.html>.

Этот учебник говорит о довольно абсолютных терминах и предоставляет лишь ограниченное представление
о богатстве функций обработки символов, которые Perl может предложить. Для
большинства проектов этой информации, вероятно, будет достаточно.

=head2 Определения

Важно, чтобы мы установиили сначала  несколько вещей. Это самая важная
часть этого учебника. Эта точка зрения может конфликтовать с другой информацией, что вы
возможно, нашли в Интернете, но это главным образом потому, что многие источники неправильны.

Возможно, вам придется перечитать этот весь раздел несколько раз...

=head3 Юникод

B<Юникод>— это набор символов с дополнительным окном для всех символов. Порядковый номер
 символа называется B<кодовой точкой>. (Но на практике,
стирается различие между кодовой точкой и символом, так что термины часто
используются как синонимы.)

Есть многие, многие кодовые точки, но компьютеры работают с байтами и байт имеет
окно только для только 256 значений. Юникод имеет намного больше символов, чем это,
так что вам нужен метод, чтобы сделать их доступными.

Юникод кодируется с использованием нескольких конкурирующих кодировок, в которых UTF-8 является 
наиболее часто используемой. В кодировке Юникод несколько последующих байтов могут использоваться для
хранения одной кодовой точки или просто: символа.

=head3 UTF-8

B <UTF-8> это Unicode кодировке. Многие люди думают, что Unicode и UTF-8
то же самое, но они это не так. Есть более кодировки Юникода, но большая часть
мир стандартизированы на UTF-8.

B<UTF-8> это Юникодная кодировка. Многие люди думают, что Юникод и UTF-8
- это одно и то же, но это не так. Есть много Юникодных кодировок, но большая часть
мира стандартизирована для на UTF-8.

UTF-8 рассматривает первые 128 кодовых точке, 0..127, так же, как ASCII. Она принимает
только один байт на символ. Все остальные символы кодируются как два или более (до шести) байт,
используя сложную схему. К счастью Perl обрабатывает это для
нас, поэтому мы не должны беспокоиться об этом.

=head3 Текстовые строки (строки символов)

B<Текстовые строки>, или B<символьные строки> изготовлены из символов. Байт
Здесь не имеет значения, а только кодировка. Каждый символ это просто символ.

С текстовой строкой вы можете делать такие вещи:

    $text =~ s/foo/bar/;
    if ($string =~ /^\d+$/) { ... }
    $text = ucfirst $text;
    my $character_count = length $text;

Значение соответствующего кода символа (C<ord>, С<chr>) связано с Юникодной кодовой точкой.

=head3 Двоичные строки (строки байтов)

B<Двоичные строки>, или B<строки байтов> изготовлены из байтов. Здесь вы не должны
символов, просто байт. Все коммуникации с внешним миром (ничего
за пределами вашего текущего процесса Perl) делается в двоичном виде.

B<Binary strings>, or B<byte strings> are made of bytes. Here, you don't have
characters, just bytes. All communication with the outside world (anything
outside of your current Perl process) is done in binary.

On a binary string, you would do things like:

    my (@length_content) = unpack "(V/a)*", $binary;
    $binary =~ s/\x00\x0F/\xFF\xF0/;  # for the brave :)
    print {$fh} $binary;
    my $byte_count = length $binary;

=head3 Encoding

B<Encoding> (as a verb) is the conversion from I<text> to I<binary>. To encode,
you have to supply the target encoding, for example C<iso-8859-1> or C<UTF-8>.
Some encodings, like the C<iso-8859> ("latin") range, do not support the full
Unicode standard; characters that can't be represented are lost in the
conversion.

=head3 Decoding

B<Decoding> is the conversion from I<binary> to I<text>. To decode, you have to
know what encoding was used during the encoding phase. And most of all, it must
be something decodable. It doesn't make much sense to decode a PNG image into a
text string.

=head3 Internal format

Perl has an B<internal format>, an encoding that it uses to encode text strings
so it can store them in memory. All text strings are in this internal format.
In fact, text strings are never in any other format!

You shouldn't worry about what this format is, because conversion is
automatically done when you decode or encode.

=head2 Your new toolkit

Add to your standard heading the following line:

    use Encode qw(encode decode);

Or, if you're lazy, just:

    use Encode;

=head2 I/O flow (the actual 5 minute tutorial)

The typical input/output flow of a program is:

    1. Receive and decode
    2. Process
    3. Encode and output

If your input is binary, and is supposed to remain binary, you shouldn't decode
it to a text string, of course. But in all other cases, you should decode it.

Decoding can't happen reliably if you don't know how the data was encoded. If
you get to choose, it's a good idea to standardize on UTF-8.

    my $foo   = decode('UTF-8', get 'http://example.com/');
    my $bar   = decode('ISO-8859-1', readline STDIN);
    my $xyzzy = decode('Windows-1251', $cgi->param('foo'));

Processing happens as you knew before. The only difference is that you're now
using characters instead of bytes. That's very useful if you use things like
C<substr>, or C<length>.

It's important to realize that there are no bytes in a text string. Of course,
Perl has its internal encoding to store the string in memory, but ignore that.
If you have to do anything with the number of bytes, it's probably best to move
that part to step 3, just after you've encoded the string. Then you know
exactly how many bytes it will be in the destination string.

The syntax for encoding text strings to binary strings is as simple as decoding:

    $body = encode('UTF-8', $body);

If you needed to know the length of the string in bytes, now's the perfect time
for that. Because C<$body> is now a byte string, C<length> will report the
number of bytes, instead of the number of characters. The number of
characters is no longer known, because characters only exist in text strings.

    my $byte_count = length $body;

And if the protocol you're using supports a way of letting the recipient know
which character encoding you used, please help the receiving end by using that
feature! For example, E-mail and HTTP support MIME headers, so you can use the
C<Content-Type> header. They can also have C<Content-Length> to indicate the
number of I<bytes>, which is always a good idea to supply if the number is
known.

    "Content-Type: text/plain; charset=UTF-8",
    "Content-Length: $byte_count"

=head1 SUMMARY

Decode everything you receive, encode everything you send out. (If it's text
data.)

=head1 Q and A (or FAQ)

After reading this document, you ought to read L<perlunifaq> too. 

=head1 ACKNOWLEDGEMENTS

Thanks to Johan Vromans from Squirrel Consultancy. His UTF-8 rants during the
Amsterdam Perl Mongers meetings got me interested and determined to find out
how to use character encodings in Perl in ways that don't break easily.

Thanks to Gerard Goossen from TTY. His presentation "UTF-8 in the wild" (Dutch
Perl Workshop 2006) inspired me to publish my thoughts and write this tutorial.

Thanks to the people who asked about this kind of stuff in several Perl IRC
channels, and have constantly reminded me that a simpler explanation was
needed.

Thanks to the people who reviewed this document for me, before it went public.
They are: Benjamin Smith, Jan-Pieter Cornet, Johan Vromans, Lukas Mai, Nathan
Gray.

=head1 AUTHOR

Juerd Waalboer <#####@juerd.nl>

=head1 SEE ALSO

L<perlunifaq>, L<perlunicode>, L<perluniintro>, L<Encode>

=head1 ПЕРЕВОДЧИКИ
 
=over
 
=item * Николай Мишин C<< <mi@ya.ru> >>
 
=back
